# Milestone v1.1: Swift Integration (Server Mode)

**Status:** SHIPPED 2026-02-17
**Phases:** 8-11
**Total Plans:** 5

## Overview

Added a Unix domain socket server mode (`mac-cleaner serve`) so a native Swift macOS app can control scanning and cleanup with real-time streaming progress, while keeping the CLI fully standalone. Engine layer decouples scan/cleanup orchestration from cobra. Single binary, two modes.

## Phases

### Phase 8: Engine Extraction

**Goal**: Extract scan/cleanup orchestration from `cmd/root.go` into `internal/engine/`
**Depends on**: Phase 7 (v1.0)
**Plans**: 2 plans

Plans:

- [x] 08-01: Build engine package — Scanner interface, Engine struct, channel-based ScanAll/Cleanup, token store, custom errors, tests
- [x] 08-02: Wire CLI and server to use Engine struct, remove direct pkg/* imports, verify zero behavior change

**Details:**
- Created `internal/engine/` package with Scanner interface, adapter pattern, channel-based streaming API
- ScanToken with single-token store and replay protection
- Custom error types: ScanError, CancelledError, TokenError (errors.As compatible)
- RegisterDefaults() registering all 6 scanner groups with full metadata
- Removed all direct `pkg/*` imports from CLI — all scanning through Engine
- Table-driven flag-to-scanner mapping in CLI
- Token round-trip protocol: scan result includes token, cleanup requires token

### Phase 9: Protocol & Server Core

**Goal**: Unix domain socket server with NDJSON protocol and `ping` handler
**Depends on**: Phase 8
**Plans**: 1 plan

Plans:

- [x] 09-01: Verify and close Phase 9 requirements (all proactively implemented in Phase 8), add supplemental test coverage, update REQUIREMENTS.md

**Details:**
- Phase 9 requirements verified as already implemented during Phase 8 engine extraction work
- Added TestServer_ActiveServerBlocks covering the active-listener code path
- NDJSON request/response protocol with request IDs
- Unix domain socket listener with graceful shutdown
- `serve` cobra subcommand with `--socket` flag
- Socket file cleanup on shutdown and stale socket detection on startup

### Phase 10: Scan & Cleanup Handlers

**Goal**: Verify scan and cleanup handler streaming flows with integration tests, fix Swift doc naming discrepancy
**Depends on**: Phase 9
**Plans**: 1 plan

Plans:

- [x] 10-01: Add integration tests for streaming scan/cleanup/concurrent-rejection/skip-params, fix Swift doc event names, update REQUIREMENTS.md

**Details:**
- 4 socket-level integration tests for scan streaming, cleanup flow, concurrent rejection, and skip filtering
- Mock engine with deterministic fake scanners for socket-level tests
- Line-based NDJSON streaming reader for test assertions
- Fixed Swift integration docs to use correct cleanup event names
- All 5 protocol methods verified: scan, cleanup, categories, ping, shutdown

### Phase 11: Hardening & Documentation

**Goal**: Production hardening with disconnect/timeout tests, dead code removal, and Swift doc enhancements
**Depends on**: Phase 10
**Plans**: 1 plan

Plans:

- [x] 11-01: Add hardening tests (disconnect-during-scan, disconnect-during-cleanup, idle timeout), make IdleTimeout configurable, remove dead ReadTimeout, enhance Swift docs, mark all HARD requirements complete

**Details:**
- 3 new integration tests: disconnect during scan, disconnect during cleanup, idle timeout
- Configurable IdleTimeout on Server struct (default 5 minutes)
- Removed dead ReadTimeout constant
- "Connection Behavior" section added to Swift integration docs
- Cleanup continues to completion on disconnect (partially-deleted state is worse)

---

## Milestone Summary

**Decimal Phases:** None

**Key Decisions:**

- Sequential scanner execution in ScanAll() (matching current behavior; concurrent can be added later)
- Single-token store (new scan invalidates previous; avoids memory leak)
- Run() returns synchronously (channels overkill for single-scanner calls)
- CLI cleanup stays in cmd/root.go (interactive confirmation is CLI-specific UI logic)
- Engine initialized in PreRun (after flag expansion, before command execution)
- Token round-trip: scan result includes token, cleanup requires token (protocol change)
- Used os.TempDir() for Unix socket test paths to avoid macOS 104-char limit
- IdleTimeout exposed as public struct field (not constructor param) for test override flexibility
- Cleanup continues to completion on disconnect (partially-deleted state is worse)
- UDS over XPC for Swift integration (Go XPC is dead ecosystem, UDS+JSON proven by Tailscale)
- NDJSON protocol (simple, streamable, debuggable with standard tools)
- Single-connection server (simplifies state management; macOS app is sole client)

**Issues Resolved:**

- Fixed 8 pre-existing gosec G104 findings in server.go
- Fixed Swift integration doc cleanup event names to match wire format
- Removed dead ReadTimeout constant

**Issues Deferred:**

- Doc inaccuracy: swift-integration.md states tokens are "per-connection and invalidated on disconnect" but tokens are actually engine-lifetime and invalidated by next scan or consumed by cleanup (Low severity, non-breaking)

**Technical Debt Incurred:**

- Minor doc inaccuracy in token lifecycle description (fix in next milestone or when Swift app is built)

---

_For current project status, see .planning/MILESTONES.md_
