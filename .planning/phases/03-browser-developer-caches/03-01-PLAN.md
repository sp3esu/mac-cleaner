---
phase: 03-browser-developer-caches
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/scan/helpers.go
  - internal/scan/helpers_test.go
  - pkg/browser/scanner.go
  - pkg/browser/scanner_test.go
  - cmd/root.go
autonomous: true

must_haves:
  truths:
    - "User can run mac-cleaner --browser-data --dry-run and see browser cache sizes"
    - "Missing browsers (Chrome/Firefox not installed) produce no output, no errors"
    - "Safari TCC permission failure prints a stderr hint and continues"
    - "Chrome multi-profile caches are all discovered and sized"
    - "Firefox cache is discovered via ~/Library/Caches/Firefox/ tree"
  artifacts:
    - path: "internal/scan/helpers.go"
      provides: "Shared ScanTopLevel function for all scanner packages"
      exports: ["ScanTopLevel"]
    - path: "internal/scan/helpers_test.go"
      provides: "Tests for shared ScanTopLevel"
    - path: "pkg/browser/scanner.go"
      provides: "Browser cache scanner for Safari, Chrome, Firefox"
      exports: ["Scan"]
    - path: "pkg/browser/scanner_test.go"
      provides: "Tests with temp dirs simulating missing/present browsers"
    - path: "cmd/root.go"
      provides: "--browser-data flag, generalized printResults with title param"
  key_links:
    - from: "pkg/browser/scanner.go"
      to: "internal/scan/helpers.go"
      via: "scan.ScanTopLevel call"
      pattern: "scan\\.ScanTopLevel"
    - from: "cmd/root.go"
      to: "pkg/browser/scanner.go"
      via: "browser.Scan() in runBrowserDataScan"
      pattern: "browser\\.Scan\\(\\)"
    - from: "cmd/root.go"
      to: "printResults"
      via: "generalized title parameter"
      pattern: "printResults\\(.*,.*,.*\\)"
---

<objective>
Extract the scanTopLevel pattern into a shared utility, build the browser cache scanner (Safari, Chrome, Firefox), generalize printResults to support multiple scan categories, and wire the --browser-data CLI flag.

Purpose: Enables users to discover reclaimable space from browser caches with graceful handling of missing browsers and TCC-protected Safari.
Output: Working `--browser-data` flag that scans and reports browser cache sizes.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-developer-caches/03-RESEARCH.md
@internal/scan/types.go
@internal/scan/size.go
@pkg/system/scanner.go
@pkg/system/scanner_test.go
@cmd/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract ScanTopLevel to shared helper and build browser scanner</name>
  <files>internal/scan/helpers.go, internal/scan/helpers_test.go, pkg/browser/scanner.go, pkg/browser/scanner_test.go, pkg/system/scanner.go</files>
  <action>
**Step 1: Create `internal/scan/helpers.go`**

Extract the `scanTopLevel` logic from `pkg/system/scanner.go` into a new exported function `scan.ScanTopLevel(dir, category, description string) (*CategoryResult, error)`. The implementation is identical to the current `system.scanTopLevel` -- it reads top-level entries, calculates sizes via `DirSize`, skips zero-byte entries, sorts descending, and checks `safety.IsPathBlocked`. Import `internal/safety` for the blocked-path checks.

**Step 2: Create `internal/scan/helpers_test.go`**

Write tests for the shared `ScanTopLevel`:
- `TestScanTopLevel`: temp dir with two subdirs of known sizes, verify entry count, total size, descending sort order
- `TestScanTopLevelSkipsZeroBytes`: empty subdir skipped
- `TestScanTopLevelNonExistent`: returns error for missing path
- `TestScanTopLevelHandlesFiles`: mix of files and dirs at top level

These mirror the existing tests in `pkg/system/scanner_test.go` but test the shared version.

**Step 3: Update `pkg/system/scanner.go`**

Replace the private `scanTopLevel` function with calls to `scan.ScanTopLevel`. The three call sites in `Scan()` change from `scanTopLevel(...)` to `scan.ScanTopLevel(...)`. Remove the private `scanTopLevel` function entirely. Keep `scanQuickLook` and `quickLookCacheDir` as-is (they have special logic not suitable for the generic helper). Verify existing system tests still pass.

**Step 4: Create `pkg/browser/scanner.go`**

Create `package browser` with an exported `Scan() ([]scan.CategoryResult, error)` function. It calls three private helpers and collects non-nil results:

- `scanSafari(home string) *scan.CategoryResult` -- Scans `~/Library/Caches/com.apple.Safari/`. Use `scan.DirSize` on the single directory (not `ScanTopLevel`, since we want one entry for the whole Safari cache dir). Handle TCC "Operation not permitted" errors: if `os.ReadDir` or `scan.DirSize` returns a permission error (`os.IsPermission(err)`), print to stderr: `fmt.Fprintf(os.Stderr, "Safari cache: grant Full Disk Access in System Settings to scan\n")` and return nil. If directory doesn't exist, return nil silently. If it exists and is accessible, return a CategoryResult with category "browser-safari", description "Safari Cache", one ScanEntry with path and total size.

- `scanChrome(home string) *scan.CategoryResult` -- Scans `~/Library/Caches/Google/Chrome/`. If that directory doesn't exist (`os.Stat` fails), return nil. Otherwise, `os.ReadDir` to enumerate all subdirectories (Default, Profile 1, Profile 2, etc.). For each subdirectory, calculate size with `scan.DirSize`. Skip zero-byte entries. Build ScanEntry items with description "Chrome ({profile name})". Sort by size descending. Return CategoryResult with category "browser-chrome", description "Chrome Cache".

- `scanFirefox(home string) *scan.CategoryResult` -- Scans `~/Library/Caches/Firefox/`. If directory doesn't exist, return nil. Use `scan.ScanTopLevel` since Firefox cache follows the standard directory-of-subdirectories pattern. Category "browser-firefox", description "Firefox Cache".

Important: Check cache directory existence (not .app bundle existence) per research recommendation. Missing cache dir = browser not installed or cache empty = return nil, not error.

**Step 5: Create `pkg/browser/scanner_test.go`**

Table-driven tests using temp directories as fake home:

- `TestScanSafariMissing`: no Safari cache dir exists, returns nil
- `TestScanSafariWithData`: create `Library/Caches/com.apple.Safari/` with files, verify CategoryResult has correct size
- `TestScanChromeMissing`: no Chrome cache dir exists, returns nil
- `TestScanChromeWithData`: create `Library/Caches/Google/Chrome/Default/Cache/` with files, verify result
- `TestScanChromeMultipleProfiles`: create Default/ and "Profile 1/" dirs with files, verify both appear in entries
- `TestScanFirefoxMissing`: no Firefox cache dir, returns nil
- `TestScanFirefoxWithData`: create `Library/Caches/Firefox/Profiles/abc123/cache2/` with files, verify result
- `TestScanIntegration`: full Scan() with fake home containing Chrome and Firefox data (no Safari), verify 2 CategoryResults returned, Safari silently skipped
- `TestScanEmptyHome`: Scan() with empty temp dir returns empty slice, no error

Use a `writeFile(t, path, size)` helper like in `pkg/system/scanner_test.go`.
  </action>
  <verify>
Run `go test ./internal/scan/ ./pkg/system/ ./pkg/browser/` -- all tests pass. Run `go vet ./...` -- no issues.
  </verify>
  <done>
Shared ScanTopLevel in internal/scan/helpers.go works identically to old system.scanTopLevel. System scanner uses shared version (existing tests pass). Browser scanner discovers Safari (with TCC handling), Chrome (multi-profile), and Firefox caches. All browser tests pass with temp dir simulation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generalize printResults and wire --browser-data flag</name>
  <files>cmd/root.go</files>
  <action>
**Step 1: Generalize `printResults`**

Change the signature from `printResults(results []scan.CategoryResult, dryRun bool)` to `printResults(results []scan.CategoryResult, dryRun bool, title string)`. Replace the hardcoded `"System Caches"` with the `title` parameter. Update the empty-results message from `"No system caches found."` to `fmt.Sprintf("No %s found.", strings.ToLower(title))`. Update the existing `runSystemCachesScan` call to pass `"System Caches"` as the title.

**Step 2: Add --browser-data flag**

Add `flagBrowserData bool` to the package-level var block. In `init()`, register: `rootCmd.Flags().BoolVar(&flagBrowserData, "browser-data", false, "scan Safari, Chrome, and Firefox caches")`.

**Step 3: Add runBrowserDataScan function**

```go
func runBrowserDataScan(cmd *cobra.Command) {
    results, err := browser.Scan()
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        return
    }
    printResults(results, flagDryRun, "Browser Data")
}
```

Add `"github.com/gregor/mac-cleaner/pkg/browser"` to imports.

**Step 4: Update the Run function**

Change the Run function to support multiple flags in one invocation. Replace the early-return pattern with a `ran` boolean tracker:

```go
Run: func(cmd *cobra.Command, args []string) {
    ran := false
    if flagSystemCaches {
        runSystemCachesScan(cmd)
        ran = true
    }
    if flagBrowserData {
        runBrowserDataScan(cmd)
        ran = true
    }
    if !ran {
        cmd.Help()
    }
},
```

This allows `mac-cleaner --system-caches --browser-data --dry-run` to run both scans. The `if !ran` block shows help when no scan flag is provided (same as current behavior).
  </action>
  <verify>
Run `go build -o /dev/null ./...` -- compiles. Run `go test ./...` -- all tests pass. Manual test: `go run . --browser-data --dry-run` produces output (or graceful empty message if no browsers installed). Run `go run . --help` and verify `--browser-data` flag appears in usage.
  </verify>
  <done>
printResults accepts a title parameter (no longer hardcoded "System Caches"). --browser-data flag is registered and wired to browser.Scan(). Multiple scan flags can be used together. `go run . --browser-data --dry-run` shows browser cache scan results.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` -- all tests pass (internal/scan, pkg/system, pkg/browser)
2. `go vet ./...` -- no issues
3. `go run . --browser-data --dry-run` -- shows browser data scan (or graceful empty if no browsers)
4. `go run . --system-caches --dry-run` -- still works (regression check)
5. `go run . --system-caches --browser-data --dry-run` -- both scans run
6. `go run . --help` -- shows --browser-data flag
</verification>

<success_criteria>
- Browser scanner discovers Chrome and Firefox caches (Safari depends on TCC permissions)
- Missing browsers produce no output and no errors
- Safari TCC failure prints stderr hint and continues
- Chrome multi-profile directories all scanned
- printResults generalized with title parameter, no regression on system caches output
- --browser-data flag wired and functional
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-developer-caches/03-01-SUMMARY.md`
</output>
