---
phase: 03-browser-developer-caches
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - pkg/developer/scanner.go
  - pkg/developer/scanner_test.go
  - cmd/root.go
autonomous: true

must_haves:
  truths:
    - "User can run mac-cleaner --dev-caches --dry-run and see developer cache sizes"
    - "Xcode DerivedData scanned when present, silently skipped when absent"
    - "npm cache at ~/.npm/ scanned (not ~/Library/Caches/)"
    - "yarn cache at ~/Library/Caches/yarn/ scanned when present"
    - "Homebrew cache at ~/Library/Caches/Homebrew/ scanned when present"
    - "Docker reclaimable space shown via docker system df when Docker is running"
    - "Docker not installed or not running produces no output, no errors, no hang"
    - "Summary shows space breakdown per developer tool"
  artifacts:
    - path: "pkg/developer/scanner.go"
      provides: "Developer cache scanner for Xcode, npm, yarn, Homebrew, Docker"
      exports: ["Scan"]
    - path: "pkg/developer/scanner_test.go"
      provides: "Tests with temp dirs and Docker CLI mocking"
    - path: "cmd/root.go"
      provides: "--dev-caches flag wired to developer.Scan()"
  key_links:
    - from: "pkg/developer/scanner.go"
      to: "internal/scan/helpers.go"
      via: "scan.ScanTopLevel for Xcode DerivedData"
      pattern: "scan\\.ScanTopLevel"
    - from: "pkg/developer/scanner.go"
      to: "internal/scan/size.go"
      via: "scan.DirSize for npm and yarn"
      pattern: "scan\\.DirSize"
    - from: "pkg/developer/scanner.go"
      to: "docker CLI"
      via: "os/exec with 10s timeout"
      pattern: "exec\\.CommandContext"
    - from: "cmd/root.go"
      to: "pkg/developer/scanner.go"
      via: "developer.Scan() in runDevCachesScan"
      pattern: "developer\\.Scan\\(\\)"
---

<objective>
Build the developer cache scanner covering Xcode DerivedData, npm cache, yarn cache, Homebrew cache, and Docker artifacts. Wire the --dev-caches CLI flag. Docker integration uses os/exec with timeout and dependency injection for testability.

Purpose: Enables users to discover reclaimable space from developer tools, including Docker artifacts that can only be queried via CLI.
Output: Working `--dev-caches` flag that scans and reports developer cache sizes with per-tool breakdown.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-developer-caches/03-RESEARCH.md
@.planning/phases/03-browser-developer-caches/03-01-SUMMARY.md
@internal/scan/types.go
@internal/scan/size.go
@internal/scan/helpers.go
@cmd/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build developer cache scanner with Docker CLI integration</name>
  <files>pkg/developer/scanner.go, pkg/developer/scanner_test.go</files>
  <action>
**Step 1: Create `pkg/developer/scanner.go`**

Create `package developer` with these exports and internals:

**CmdRunner type** for Docker CLI dependency injection:
```go
// CmdRunner executes an external command and returns its output.
// Used for dependency injection in Docker scanning.
type CmdRunner func(ctx context.Context, name string, args ...string) ([]byte, error)

// defaultRunner uses os/exec to run commands.
func defaultRunner(ctx context.Context, name string, args ...string) ([]byte, error) {
    cmd := exec.CommandContext(ctx, name, args...)
    return cmd.Output()
}
```

**Scan function:**
```go
func Scan() ([]scan.CategoryResult, error)
```
Gets home dir, calls each scanner, collects non-nil results. Uses `defaultRunner` for Docker. Follows same pattern as browser.Scan() and system.Scan().

**Private scanner functions:**

- `scanXcodeDerivedData(home string) *scan.CategoryResult` -- Path: `~/Library/Developer/Xcode/DerivedData/`. Check with `os.Stat`; if not found or not a dir, return nil. Use `scan.ScanTopLevel(derivedData, "dev-xcode", "Xcode DerivedData")`. Each top-level entry is a project build folder.

- `scanNpmCache(home string) *scan.CategoryResult` -- Path: `~/.npm/` (NOT ~/Library/Caches). Check with `os.Stat`; if not found, return nil. Use `scan.ScanTopLevel(npmDir, "dev-npm", "npm Cache")`. This will enumerate `_cacache/`, `_npx/`, `_logs/` etc. as separate entries.

- `scanYarnCache(home string) *scan.CategoryResult` -- Path: `~/Library/Caches/yarn/`. Check with `os.Stat`; if not found, return nil. Calculate total size with `scan.DirSize` since yarn cache is a single blob. Return a single-entry CategoryResult with category "dev-yarn", description "yarn Cache".

- `scanHomebrew(home string) *scan.CategoryResult` -- Path: `~/Library/Caches/Homebrew/`. Check with `os.Stat`; if not found, return nil. Use `scan.ScanTopLevel(brewDir, "dev-homebrew", "Homebrew Cache")` to show downloads/, Cask/, etc. as separate entries.

- `scanDocker(runner CmdRunner) *scan.CategoryResult` -- No filesystem path. First check if docker binary exists with `exec.LookPath("docker")`; if not found, return nil. Create context with 10-second timeout. Call `runner(ctx, dockerPath, "system", "df", "--format", "json")`. If error (daemon not running, timeout, etc.), return nil. Parse JSON lines -- each line is a `dockerDfEntry` struct with fields Type, TotalCount, Size, Reclaimable, Active (all strings). For each line, extract the reclaimable size using `parseDockerSize`. Skip entries with 0 reclaimable bytes. Build ScanEntry items with path "docker:{Type}" and description "Docker {Type} (reclaimable)". Return CategoryResult with category "dev-docker", description "Docker Artifacts".

**parseDockerSize function:**
```go
func parseDockerSize(s string) int64
```
Parse Docker's size strings like "16.43MB", "2.3GB", "0B", "212B". Strip the percentage part if present: "11.63MB (70%)" becomes "11.63MB". Parse the numeric part and unit. Supported units: B, kB, MB, GB, TB (Docker uses SI/decimal units). Return size in bytes. Return 0 for unparseable strings.

**Step 2: Create `pkg/developer/scanner_test.go`**

Tests using temp directories and Docker CLI mocking:

**Filesystem-based scanner tests (temp dir as fake home):**
- `TestScanXcodeMissing`: no DerivedData dir, returns nil
- `TestScanXcodeWithData`: create `Library/Developer/Xcode/DerivedData/MyProject/` with files, verify CategoryResult
- `TestScanXcodeEmptyDir`: DerivedData exists but is empty, verify nil or empty entries (zero-byte filtering)
- `TestScanNpmMissing`: no ~/.npm dir, returns nil
- `TestScanNpmWithData`: create `.npm/_cacache/` and `.npm/_npx/` with files, verify entries and sizes
- `TestScanYarnMissing`: no yarn cache dir, returns nil
- `TestScanYarnWithData`: create `Library/Caches/yarn/` with files, verify single-entry result
- `TestScanHomebrewMissing`: no Homebrew cache, returns nil
- `TestScanHomebrewWithData`: create `Library/Caches/Homebrew/downloads/` with files, verify result

**Docker CLI mock tests:**
- `TestScanDockerNotInstalled`: mock runner returns exec.ErrNotFound, verify nil result
- `TestScanDockerDaemonStopped`: mock runner returns non-nil error, verify nil result
- `TestScanDockerWithData`: mock runner returns realistic JSON lines (Images: 16.43MB reclaimable, Containers: 212B reclaimable, Local Volumes: 0B reclaimable, Build Cache: 0B reclaimable). Verify 2 entries returned (Images + Containers), 0B entries filtered out, sizes parsed correctly.
- `TestScanDockerEmptyOutput`: mock returns empty output, verify nil result

**parseDockerSize tests:**
- `TestParseDockerSize`: table-driven with cases: "0B" -> 0, "212B" -> 212, "16.43MB" -> 16430000, "2.3GB" -> 2300000000, "1.5kB" -> 1500, "11.63MB (70%)" -> 11630000, "" -> 0, "invalid" -> 0

**Integration test:**
- `TestScanIntegration`: create a fake home with npm and Xcode data. Use a mock Docker runner returning data. Call a `scanWithRunner(runner CmdRunner)` variant (or set up the scanner to accept options). Verify multiple CategoryResults returned.

Use `writeFile(t, path, size)` helper.
  </action>
  <verify>
Run `go test ./pkg/developer/` -- all tests pass. Run `go vet ./pkg/developer/` -- no issues.
  </verify>
  <done>
Developer scanner discovers Xcode DerivedData, npm cache (at ~/.npm/), yarn cache, Homebrew cache, and Docker artifacts. Docker integration uses CmdRunner injection for testability. Missing tools produce nil results. parseDockerSize handles all Docker size formats. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire --dev-caches flag in CLI</name>
  <files>cmd/root.go</files>
  <action>
**Step 1: Add --dev-caches flag**

Add `flagDevCaches bool` to the package-level var block. In `init()`, register: `rootCmd.Flags().BoolVar(&flagDevCaches, "dev-caches", false, "scan Xcode, npm/yarn, Homebrew, and Docker caches")`.

**Step 2: Add runDevCachesScan function**

```go
func runDevCachesScan(cmd *cobra.Command) {
    results, err := developer.Scan()
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        return
    }
    printResults(results, flagDryRun, "Developer Caches")
}
```

Add `"github.com/gregor/mac-cleaner/pkg/developer"` to imports.

**Step 3: Update the Run function**

Add the `flagDevCaches` check to the `Run` function, after the existing `flagBrowserData` block (which was added in plan 03-01):

```go
if flagDevCaches {
    runDevCachesScan(cmd)
    ran = true
}
```

The full Run function should now handle all three scan flags: `flagSystemCaches`, `flagBrowserData`, `flagDevCaches`. All three can be combined in one invocation.
  </action>
  <verify>
Run `go build -o /dev/null ./...` -- compiles. Run `go test ./...` -- all tests pass. Manual test: `go run . --dev-caches --dry-run` produces output showing developer caches found. Run `go run . --help` and verify `--dev-caches` flag appears. Run `go run . --system-caches --browser-data --dev-caches --dry-run` to verify all three work together.
  </verify>
  <done>
--dev-caches flag registered and wired to developer.Scan(). All three scan flags (--system-caches, --browser-data, --dev-caches) work independently and together. `go run . --dev-caches --dry-run` shows developer cache scan results with per-tool breakdown.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` -- all tests pass (internal/scan, pkg/system, pkg/browser, pkg/developer)
2. `go vet ./...` -- no issues
3. `go run . --dev-caches --dry-run` -- shows developer caches (Xcode, npm, Homebrew, etc.)
4. `go run . --browser-data --dev-caches --dry-run` -- both scans run together
5. `go run . --system-caches --browser-data --dev-caches --dry-run` -- all three scans
6. Docker scan: if Docker is running, shows reclaimable space; if not, silently skips
7. `go run . --help` -- shows all three scan flags
</verification>

<success_criteria>
- Developer scanner discovers all 5 tool categories (Xcode, npm, yarn, Homebrew, Docker)
- Missing tools produce no output and no errors
- Docker CLI integration uses 10s timeout and graceful failure
- Docker reclaimable sizes parsed correctly from JSON output
- npm cache found at ~/.npm/ (not ~/Library/Caches/)
- --dev-caches flag wired and functional
- All three scan flags can be combined in one invocation
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-developer-caches/03-02-SUMMARY.md`
</output>
