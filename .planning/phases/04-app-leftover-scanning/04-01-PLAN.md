---
phase: 04-app-leftover-scanning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/appleftovers/scanner.go
  - pkg/appleftovers/scanner_test.go
  - cmd/root.go
autonomous: true

must_haves:
  truths:
    - "User can scan orphaned app preferences from uninstalled apps with --app-leftovers"
    - "User can scan old iOS device backups with --app-leftovers"
    - "User can scan old files in ~/Downloads (older than 90 days) with --app-leftovers"
    - "Missing directories (no iOS backups, no Downloads) are silently skipped"
    - "com.apple.* preferences are never flagged as orphaned"
  artifacts:
    - path: "pkg/appleftovers/scanner.go"
      provides: "App leftover scanner with three sub-scanners"
      exports: ["Scan", "CmdRunner"]
    - path: "pkg/appleftovers/scanner_test.go"
      provides: "Tests for all three sub-scanners"
    - path: "cmd/root.go"
      provides: "--app-leftovers flag and runAppLeftoversScan function"
  key_links:
    - from: "pkg/appleftovers/scanner.go"
      to: "internal/scan/types.go"
      via: "scan.CategoryResult return type"
      pattern: "scan\\.CategoryResult"
    - from: "pkg/appleftovers/scanner.go"
      to: "internal/scan/helpers.go"
      via: "scan.ScanTopLevel for iOS backups"
      pattern: "scan\\.ScanTopLevel"
    - from: "cmd/root.go"
      to: "pkg/appleftovers/scanner.go"
      via: "appleftovers.Scan() call in runAppLeftoversScan"
      pattern: "appleftovers\\.Scan\\(\\)"
---

<objective>
Build the app leftovers scanner covering three sub-categories: orphaned preferences from uninstalled apps, iOS device backups, and old Downloads files. Wire to CLI with --app-leftovers flag.

Purpose: Implements APP-01 (orphaned prefs), APP-02 (iOS backups), APP-03 (old Downloads) scanning. This is the third scanning category, following the established scanner pattern from Phases 2-3.
Output: `pkg/appleftovers/scanner.go`, `pkg/appleftovers/scanner_test.go`, updated `cmd/root.go`
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-app-leftover-scanning/04-RESEARCH.md
@.planning/phases/03-browser-developer-caches/03-02-SUMMARY.md
@pkg/developer/scanner.go
@internal/scan/types.go
@internal/scan/helpers.go
@cmd/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build app leftovers scanner with three sub-scanners</name>
  <files>pkg/appleftovers/scanner.go, pkg/appleftovers/scanner_test.go</files>
  <action>
Create `pkg/appleftovers/scanner.go` following the exact pattern of `pkg/developer/scanner.go`:

1. **Package and exports:**
   - Package `appleftovers`
   - Export `CmdRunner` type: `type CmdRunner func(ctx context.Context, name string, args ...string) ([]byte, error)` (same as developer package, for PlistBuddy)
   - Export `Scan() ([]scan.CategoryResult, error)` that calls three private sub-scanners and aggregates results
   - `defaultRunner` using `exec.CommandContext`

2. **scanOrphanedPrefs(home string, runner CmdRunner) *scan.CategoryResult:**
   - Build set of installed bundle IDs by scanning app directories: `/Applications`, `/Applications/Utilities`, `~/Applications`, `/System/Applications`, `/System/Applications/Utilities`
   - For each `.app` entry in each directory, call PlistBuddy: `runner(ctx, "/usr/libexec/PlistBuddy", "-c", "Print :CFBundleIdentifier", filepath.Join(appPath, "Contents", "Info.plist"))`
   - Use `exec.LookPath("/usr/libexec/PlistBuddy")` guard first (same pattern as Docker). If PlistBuddy not found, return nil.
   - Use 5-second context timeout per PlistBuddy call
   - Read `os.ReadDir(filepath.Join(home, "Library", "Preferences"))` to list all `.plist` files
   - For each plist file: extract domain by stripping `.plist` suffix from filename
   - Skip `com.apple.*` domains entirely (never flag as orphaned)
   - A plist is orphaned if NO known bundle ID is a prefix of its domain: `domain == id || strings.HasPrefix(domain, id+".")`
   - Get file size via `os.Lstat` (not Stat, don't follow symlinks)
   - Skip zero-byte entries
   - Sort entries by size descending
   - Category: `"app-orphaned-prefs"`, Description: `"Orphaned Preferences"`

3. **scanIOSBackups(home string) *scan.CategoryResult:**
   - Path: `filepath.Join(home, "Library", "Application Support", "MobileSync", "Backup")`
   - Return nil if directory does not exist (`os.Stat` check)
   - Use `scan.ScanTopLevel(path, "app-ios-backups", "iOS Device Backups")`
   - Return nil if result has zero entries
   - This is the simplest sub-scanner -- it follows the ScanTopLevel pattern exactly

4. **scanOldDownloads(home string, maxAge time.Duration) *scan.CategoryResult:**
   - Path: `filepath.Join(home, "Downloads")`
   - Return nil if directory does not exist
   - `os.ReadDir(downloadsDir)` for top-level entries only (no recursion)
   - For each entry, get info via `entry.Info()` (uses Lstat semantics from ReadDir)
   - Skip entries where `time.Since(info.ModTime()) <= maxAge`
   - For directories, use `scan.DirSize()` to get total size
   - For files, use `info.Size()`
   - Skip zero-byte entries
   - Sort by size descending
   - Category: `"app-old-downloads"`, Description: `"Old Downloads (90+ days)"`
   - Hardcode `maxAge = 90 * 24 * time.Hour` in the `Scan()` function (configurability deferred to Phase 6)

Create `pkg/appleftovers/scanner_test.go` with comprehensive tests:

1. **TestScanOrphanedPrefs:** Create temp dir structure with fake Preferences dir containing .plist files (com.example.removed.plist, com.apple.finder.plist, com.known.app.plist). Create fake app dir with one .app that returns "com.known.app" from mock CmdRunner. Verify com.example.removed is flagged, com.apple.finder is skipped, com.known.app is not flagged.

2. **TestScanOrphanedPrefsNoPlistBuddy:** Test that scanner returns nil when PlistBuddy is not on PATH. Use the fakeDockerPath-style test helper but for PlistBuddy -- create temp dir with no PlistBuddy and override PATH via t.Setenv. Actually, since we use exec.LookPath for the full path "/usr/libexec/PlistBuddy", the test should mock the runner to return an error. Simpler: the LookPath check should use `exec.LookPath("PlistBuddy")` OR check `os.Stat("/usr/libexec/PlistBuddy")`. Use `os.Stat` check since PlistBuddy is at a fixed path. Then in tests, pass a home with nonexistent PlistBuddy path -- no, the scanner checks for PlistBuddy existence before calling runner. Simplest approach: check `os.Stat("/usr/libexec/PlistBuddy")` and if it doesn't exist, return nil. Tests that need to bypass this should use a package-level variable or accept a "plistBuddyPath" parameter. **Decision: make the internal scanOrphanedPrefs accept a plistBuddyPath string parameter.** In production, pass `"/usr/libexec/PlistBuddy"`. In tests, pass a fake path that exists (or doesn't, to test the guard).

3. **TestScanIOSBackups:** Create temp dir with fake MobileSync/Backup containing two UUID-named subdirs with files inside. Verify result has two entries sorted by size.

4. **TestScanIOSBackupsMissing:** Verify nil when MobileSync/Backup doesn't exist.

5. **TestScanOldDownloads:** Create temp dir with Downloads containing files of various ages. Use `os.Chtimes` to set modification times. Verify only files older than threshold are returned.

6. **TestScanOldDownloadsSkipsRecent:** All files are recent (< 90 days). Verify nil result.

7. **TestScanOrphanedPrefsApplePrefixSkipped:** Table-driven test verifying all com.apple.* variants are skipped.

All tests use `t.TempDir()` for isolation. Tests that need CmdRunner use mock functions (same pattern as Docker tests in Phase 3).
  </action>
  <verify>
Run `cd /Users/gregor/projects/mac-clarner && go test ./pkg/appleftovers/ -v` -- all tests pass.
Run `cd /Users/gregor/projects/mac-clarner && go vet ./pkg/appleftovers/` -- no issues.
  </verify>
  <done>
Three sub-scanners implemented: orphaned prefs with CmdRunner injection and prefix matching, iOS backups with ScanTopLevel, old Downloads with age filtering. All tests pass. com.apple.* prefs never flagged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire --app-leftovers flag in CLI</name>
  <files>cmd/root.go</files>
  <action>
Update `cmd/root.go` following the exact pattern of the existing --dev-caches wiring:

1. Add package-level var: `flagAppLeftovers bool`

2. In `init()`, add: `rootCmd.Flags().BoolVar(&flagAppLeftovers, "app-leftovers", false, "scan orphaned preferences, iOS backups, and old Downloads")`

3. Add import for `"github.com/gregor/mac-cleaner/pkg/appleftovers"`

4. In the root command's `Run` function, add after the `flagDevCaches` block:
   ```go
   if flagAppLeftovers {
       runAppLeftoversScan(cmd)
       ran = true
   }
   ```

5. Add `runAppLeftoversScan` function following the exact pattern of `runDevCachesScan`:
   ```go
   func runAppLeftoversScan(cmd *cobra.Command) {
       results, err := appleftovers.Scan()
       if err != nil {
           fmt.Fprintf(os.Stderr, "Error: %v\n", err)
           return
       }
       printResults(results, flagDryRun, "App Leftovers")
   }
   ```

This is purely additive wiring -- no existing behavior changes.
  </action>
  <verify>
Run `cd /Users/gregor/projects/mac-clarner && go build -o /dev/null .` -- compiles.
Run `cd /Users/gregor/projects/mac-clarner && go run . --app-leftovers --dry-run` -- shows app leftovers scan results (or "no app leftovers found" if none exist).
Run `cd /Users/gregor/projects/mac-clarner && go run . --help` -- shows --app-leftovers flag in help text.
Verify combined flags work: `go run . --system-caches --app-leftovers --dry-run` -- shows both sections.
  </verify>
  <done>
`--app-leftovers` flag wired and working. Combined with existing flags. Dry-run mode shows scan results. Help text includes new flag.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` passes (all packages including new appleftovers)
2. `go vet ./...` clean
3. `go run . --app-leftovers --dry-run` shows scan output
4. `go run . --help` lists --app-leftovers flag
5. Combined flags work: `go run . --system-caches --browser-data --dev-caches --app-leftovers --dry-run`
</verification>

<success_criteria>
- Three sub-scanners (orphaned prefs, iOS backups, old Downloads) implemented and tested
- com.apple.* preferences never flagged as orphaned
- CmdRunner injection for PlistBuddy testability
- iOS backups use ScanTopLevel pattern
- Downloads filtered by 90-day age threshold using ModTime
- --app-leftovers flag works standalone and combined with other flags
- All tests pass, no vet warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-app-leftover-scanning/04-01-SUMMARY.md`
</output>
