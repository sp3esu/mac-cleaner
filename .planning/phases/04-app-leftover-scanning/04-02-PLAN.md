---
phase: 04-app-leftover-scanning
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/confirm/confirm.go
  - internal/confirm/confirm_test.go
  - internal/cleanup/cleanup.go
  - internal/cleanup/cleanup_test.go
  - cmd/root.go
autonomous: true

must_haves:
  truths:
    - "User sees confirmation prompt listing what will be removed before deletion"
    - "User must type 'yes' to proceed with deletion"
    - "Files are permanently removed after confirmation"
    - "User sees post-cleanup summary showing items removed and space freed"
    - "Deletion never proceeds without explicit 'yes' confirmation"
    - "Dry-run mode skips confirmation prompt entirely"
    - "Safety re-check blocks protected paths at deletion time"
  artifacts:
    - path: "internal/confirm/confirm.go"
      provides: "PromptConfirmation with io.Reader/io.Writer injection"
      exports: ["PromptConfirmation"]
    - path: "internal/confirm/confirm_test.go"
      provides: "Tests for confirmation prompt"
    - path: "internal/cleanup/cleanup.go"
      provides: "Execute function for deletion with safety re-check"
      exports: ["Execute", "CleanupResult"]
    - path: "internal/cleanup/cleanup_test.go"
      provides: "Tests for cleanup execution"
    - path: "cmd/root.go"
      provides: "Deletion flow orchestration: scan -> confirm -> delete -> summary"
  key_links:
    - from: "internal/cleanup/cleanup.go"
      to: "internal/safety/safety.go"
      via: "safety.IsPathBlocked re-check before each deletion"
      pattern: "safety\\.IsPathBlocked"
    - from: "internal/cleanup/cleanup.go"
      to: "internal/scan/types.go"
      via: "Takes []scan.CategoryResult as input"
      pattern: "scan\\.CategoryResult"
    - from: "internal/confirm/confirm.go"
      to: "internal/scan/types.go"
      via: "Displays scan.CategoryResult entries"
      pattern: "scan\\.CategoryResult"
    - from: "cmd/root.go"
      to: "internal/confirm/confirm.go"
      via: "PromptConfirmation call before cleanup"
      pattern: "confirm\\.PromptConfirmation"
    - from: "cmd/root.go"
      to: "internal/cleanup/cleanup.go"
      via: "cleanup.Execute call after confirmation"
      pattern: "cleanup\\.Execute"
---

<objective>
Build the confirmation prompt and cleanup execution modules, then wire the full deletion flow into the CLI. This introduces the first actual file deletion capability.

Purpose: Implements CLI-04 (confirmation before deletion) and the deletion execution path. After this plan, users can scan AND delete app leftovers (and any future scan results) with proper confirmation and summary.
Output: `internal/confirm/confirm.go`, `internal/cleanup/cleanup.go`, updated `cmd/root.go`
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-app-leftover-scanning/04-RESEARCH.md
@.planning/phases/04-app-leftover-scanning/04-01-SUMMARY.md
@internal/safety/safety.go
@internal/scan/types.go
@cmd/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build confirmation prompt and cleanup execution packages</name>
  <files>internal/confirm/confirm.go, internal/confirm/confirm_test.go, internal/cleanup/cleanup.go, internal/cleanup/cleanup_test.go</files>
  <action>
**Create `internal/confirm/confirm.go`:**

```go
package confirm
```

1. **PromptConfirmation(in io.Reader, out io.Writer, results []scan.CategoryResult) bool:**
   - Import `scan` from `github.com/gregor/mac-cleaner/internal/scan`
   - Print header: `"\nThe following items will be permanently deleted:\n"`
   - For each CategoryResult, print its Description as a bold header (using fatih/color)
   - For each entry in the category, print `"  {path}  ({formatted size})"`  using `scan.FormatSize`
   - Shorten home directory prefix to `~` for display (accept home string parameter or compute via `os.UserHomeDir`)
   - Print total size: `"\nTotal: {size} will be permanently deleted."`
   - Print prompt: `"Type 'yes' to proceed: "`
   - Read response using `bufio.NewReader(in).ReadString('\n')`
   - Return `true` only if `strings.TrimSpace(response) == "yes"` (exact match, case-sensitive)
   - Return `false` on any read error

**Signature decision:** `PromptConfirmation(in io.Reader, out io.Writer, results []scan.CategoryResult) bool` -- keep it simple. Home dir for path shortening computed internally via `os.UserHomeDir()`.

**Create `internal/confirm/confirm_test.go`:**

1. **TestConfirmationYes:** Pass `strings.NewReader("yes\n")` and valid results. Assert returns true.
2. **TestConfirmationNo:** Pass `strings.NewReader("no\n")`. Assert returns false.
3. **TestConfirmationEmpty:** Pass `strings.NewReader("\n")`. Assert returns false.
4. **TestConfirmationYUppercase:** Pass `strings.NewReader("Yes\n")`. Assert returns false (case-sensitive, must be lowercase "yes").
5. **TestConfirmationJustY:** Pass `strings.NewReader("y\n")`. Assert returns false.
6. **TestConfirmationWithWhitespace:** Pass `strings.NewReader("  yes  \n")`. Assert returns true (TrimSpace handles it).
7. **TestConfirmationOutputContainsPath:** Pass results with a known path. Assert that the output buffer contains the path string.
8. **TestConfirmationOutputContainsSize:** Pass results with known size. Assert output buffer contains the formatted size.
9. **TestConfirmationEmptyResults:** Pass empty results slice. Assert prompt still works (returns based on user input).

**Create `internal/cleanup/cleanup.go`:**

```go
package cleanup
```

1. **CleanupResult struct:**
   ```go
   type CleanupResult struct {
       Removed    int      // Number of items successfully removed
       Failed     int      // Number of items that failed removal
       BytesFreed int64    // Total bytes from successfully removed items
       Errors     []error  // Individual error details
   }
   ```

2. **Execute(results []scan.CategoryResult) CleanupResult:**
   - Import `safety` from `github.com/gregor/mac-cleaner/internal/safety`
   - Import `scan` from `github.com/gregor/mac-cleaner/internal/scan`
   - For each entry across all CategoryResults:
     - **Re-check safety:** `if blocked, reason := safety.IsPathBlocked(entry.Path); blocked` -- skip with `safety.WarnBlocked`, increment Failed
     - **Skip pseudo-paths:** If path starts with `"docker:"` or similar non-filesystem prefix, skip (these are informational only, not deletable). Increment Failed, add error.
     - **Delete:** `os.RemoveAll(entry.Path)` -- handles both files and directories
     - If `os.RemoveAll` returns error AND `!os.IsNotExist(err)`: increment Failed, append error, continue
     - If success or path already gone: increment Removed, add entry.Size to BytesFreed
   - Return CleanupResult

**Create `internal/cleanup/cleanup_test.go`:**

1. **TestExecuteRemovesFiles:** Create temp files, build CategoryResult pointing to them. Execute. Assert files are gone. Assert Removed count and BytesFreed.
2. **TestExecuteRemovesDirectories:** Create temp dir with nested files. Build CategoryResult. Execute. Assert directory tree gone.
3. **TestExecuteContinuesOnError:** Create one valid temp file and one nonexistent path (that returns a real error, e.g., a path inside a read-only directory). Assert that the valid file is still removed even if the other fails. Assert Failed count.
4. **TestExecuteBlockedPath:** Build CategoryResult with an entry pointing to a SIP-protected path like "/System/foo". Assert it is skipped (Failed incremented), safety.WarnBlocked output on stderr.
5. **TestExecuteAlreadyGone:** Build CategoryResult with a path that doesn't exist. Assert it counts as Removed (os.RemoveAll returns nil for nonexistent paths).
6. **TestExecuteEmptyResults:** Pass empty slice. Assert zero Removed, zero Failed, zero BytesFreed.

All tests use `t.TempDir()` exclusively -- never real user directories.
  </action>
  <verify>
Run `cd /Users/gregor/projects/mac-clarner && go test ./internal/confirm/ -v` -- all tests pass.
Run `cd /Users/gregor/projects/mac-clarner && go test ./internal/cleanup/ -v` -- all tests pass.
Run `cd /Users/gregor/projects/mac-clarner && go vet ./internal/confirm/ ./internal/cleanup/` -- no issues.
  </verify>
  <done>
Confirmation prompt accepts io.Reader/io.Writer, requires exact "yes", displays itemized list. Cleanup execution re-checks safety, continues on errors, returns structured summary. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire deletion flow into CLI (scan -> confirm -> delete -> summary)</name>
  <files>cmd/root.go</files>
  <action>
Update `cmd/root.go` to orchestrate the full deletion flow when --dry-run is NOT set:

1. **Add imports:**
   - `"github.com/gregor/mac-cleaner/internal/confirm"`
   - `"github.com/gregor/mac-cleaner/internal/cleanup"`

2. **Refactor scan runner functions to return results:**
   The current `runAppLeftoversScan` (from Plan 01) prints and returns nothing. Modify to support both dry-run (print only) and live (print + return for deletion):

   Change `runAppLeftoversScan` to return `[]scan.CategoryResult`:
   ```go
   func runAppLeftoversScan(cmd *cobra.Command) []scan.CategoryResult {
       results, err := appleftovers.Scan()
       if err != nil {
           fmt.Fprintf(os.Stderr, "Error: %v\n", err)
           return nil
       }
       printResults(results, flagDryRun, "App Leftovers")
       return results
   }
   ```

   Similarly update `runSystemCachesScan`, `runBrowserDataScan`, `runDevCachesScan` to return `[]scan.CategoryResult` for future use (they already follow the same pattern). This is a non-breaking change since the return values are currently ignored.

3. **Update the root Run function for deletion flow:**
   ```go
   Run: func(cmd *cobra.Command, args []string) {
       ran := false
       var allResults []scan.CategoryResult

       if flagSystemCaches {
           allResults = append(allResults, runSystemCachesScan(cmd)...)
           ran = true
       }
       if flagBrowserData {
           allResults = append(allResults, runBrowserDataScan(cmd)...)
           ran = true
       }
       if flagDevCaches {
           allResults = append(allResults, runDevCachesScan(cmd)...)
           ran = true
       }
       if flagAppLeftovers {
           allResults = append(allResults, runAppLeftoversScan(cmd)...)
           ran = true
       }

       if !ran {
           cmd.Help()
           return
       }

       // Deletion flow: only when not in dry-run mode and there are results
       if !flagDryRun && len(allResults) > 0 {
           if !confirm.PromptConfirmation(os.Stdin, os.Stdout, allResults) {
               fmt.Println("Aborted.")
               return
           }
           result := cleanup.Execute(allResults)
           printCleanupSummary(result)
       }
   }
   ```

4. **Add printCleanupSummary function:**
   ```go
   func printCleanupSummary(result cleanup.CleanupResult) {
       greenBold := color.New(color.FgGreen, color.Bold)
       fmt.Println()
       greenBold.Printf("Cleanup complete: %d items removed, %s freed\n",
           result.Removed, scan.FormatSize(result.BytesFreed))
       if result.Failed > 0 {
           yellow := color.New(color.FgYellow)
           yellow.Printf("%d items failed (see warnings above)\n", result.Failed)
       }
       fmt.Println()
   }
   ```

5. **Dry-run behavior:** When `--dry-run` is set, the deletion flow block is skipped entirely. Scan results are printed but no confirmation prompt appears and no files are deleted. This matches the research recommendation: dry-run means "show what would happen."

**Important:** The scan functions that return `[]scan.CategoryResult` must handle nil returns from the underlying scanners gracefully. If `Scan()` returns an empty slice (or error causes nil return), `append(allResults, nil...)` is safe in Go since appending nil slice is a no-op.
  </action>
  <verify>
Run `cd /Users/gregor/projects/mac-clarner && go build -o /dev/null .` -- compiles.
Run `cd /Users/gregor/projects/mac-clarner && go vet ./...` -- no issues.
Run `cd /Users/gregor/projects/mac-clarner && go test ./...` -- all tests pass.
Test dry-run: `go run . --app-leftovers --dry-run` -- shows scan results, NO confirmation prompt.
Test help: `go run . --help` -- shows all flags.
Test combined: `go run . --system-caches --app-leftovers --dry-run` -- shows both sections.
Manual test (if safe entries exist): `go run . --app-leftovers` without --dry-run -- should show scan, then confirmation prompt. Type "no" to abort. Verify "Aborted." message and no files deleted.
  </verify>
  <done>
Full deletion flow wired: scan -> print results -> confirm (if not dry-run) -> delete -> summary. Dry-run skips confirmation and deletion. "yes" required for confirmation. Post-cleanup summary shows items removed and space freed. All scan functions return results for aggregation.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` passes (all packages)
2. `go vet ./...` clean
3. `go run . --app-leftovers --dry-run` shows scan results without confirmation prompt
4. `go run . --app-leftovers` (without --dry-run) shows scan then confirmation prompt
5. Typing "no" at confirmation prompt aborts without deleting
6. Typing "yes" at confirmation prompt executes deletion and shows summary
7. Combined flags: `go run . --system-caches --browser-data --dev-caches --app-leftovers --dry-run`
</verification>

<success_criteria>
- Confirmation prompt requires exact "yes" string (not "y", not "Y", not "Yes")
- Confirmation prompt displays each item with path and size
- Dry-run mode skips confirmation prompt entirely
- Cleanup re-checks safety.IsPathBlocked before each deletion
- Cleanup continues on individual errors (does not abort)
- Post-cleanup summary shows items removed and bytes freed
- All scan functions return results for aggregation in root command
- All tests pass, no vet warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-app-leftover-scanning/04-02-SUMMARY.md`
</output>
