---
phase: 05-interactive-mode
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/interactive/interactive.go
  - internal/interactive/interactive_test.go
  - cmd/root.go
autonomous: true

must_haves:
  truths:
    - "Running mac-cleaner with no args enters interactive walkthrough mode (not help)"
    - "Each scan entry is presented one-by-one with [N/M] progress, description, and size"
    - "User can respond k/keep or r/remove for each item; invalid input re-prompts"
    - "After walkthrough, only items marked remove are shown in confirmation summary"
    - "Final confirmation (type yes) is required before deletion proceeds"
    - "Cleanup executes only after final confirmation and shows summary"
    - "EOF on input defaults remaining items to keep (safe default)"
    - "If no items are scanned or all items kept, tool exits cleanly with message"
  artifacts:
    - path: "internal/interactive/interactive.go"
      provides: "RunWalkthrough function and readChoice helper"
      exports: ["RunWalkthrough"]
    - path: "internal/interactive/interactive_test.go"
      provides: "Tests for walkthrough logic, choice reading, edge cases"
    - path: "cmd/root.go"
      provides: "Interactive mode wiring, scanAll helper"
  key_links:
    - from: "cmd/root.go"
      to: "internal/interactive/interactive.go"
      via: "interactive.RunWalkthrough call in !ran branch"
      pattern: "interactive\\.RunWalkthrough"
    - from: "cmd/root.go"
      to: "internal/confirm/confirm.go"
      via: "confirm.PromptConfirmation with shared bufio.Reader"
      pattern: "confirm\\.PromptConfirmation"
    - from: "internal/interactive/interactive.go"
      to: "internal/scan/types.go"
      via: "accepts and returns []scan.CategoryResult"
      pattern: "scan\\.CategoryResult"
---

<objective>
Build the interactive walkthrough mode for mac-cleaner. When users run `mac-cleaner` with no flags, the tool scans all four categories, presents each item one-by-one asking keep/remove, then confirms and executes deletion of marked items.

Purpose: This is the primary user-facing mode -- the approachable default experience for general macOS users who want guided cleanup.
Output: `internal/interactive` package with RunWalkthrough function, and `cmd/root.go` wired to use it as the default no-args behavior.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-interactive-mode/05-RESEARCH.md
@.planning/phases/04-app-leftover-scanning/04-02-SUMMARY.md
@cmd/root.go
@internal/confirm/confirm.go
@internal/cleanup/cleanup.go
@internal/scan/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build interactive walkthrough package</name>
  <files>internal/interactive/interactive.go, internal/interactive/interactive_test.go</files>
  <action>
Create `internal/interactive/interactive.go` with:

1. **`RunWalkthrough(in io.Reader, out io.Writer, results []scan.CategoryResult) []scan.CategoryResult`**
   - Accept `io.Reader` and `io.Writer` (matching the established confirm package pattern for testability).
   - Count total items across all categories for progress display.
   - If totalItems == 0, print "Nothing to clean." to `out` and return nil.
   - Iterate over each CategoryResult, printing a bold category header (using fatih/color) when entering a new category.
   - For each entry, display: `  [N/M] description  formattedSize` on one line, then `  keep or remove? [k/r]: ` prompt on the next line. Use cyan (fatih/color) for the formatted size, matching established output patterns.
   - Call `readChoice` to get the user's response.
   - If response is "remove", add the entry to the removed list for that category.
   - After iterating all entries in a category, if any were removed, build a new `scan.CategoryResult` with only removed entries and the summed removed size, append to output slice.
   - If no items were marked for removal across all categories, print "Nothing marked for removal." to `out` and return nil.
   - Return the filtered `[]scan.CategoryResult` containing only removal-marked entries.

2. **`readChoice(reader *bufio.Reader, out io.Writer) string`** (unexported helper)
   - Loop: read a line with `reader.ReadString('\n')`.
   - On error (including EOF): return "keep" (safe default).
   - Normalize: `strings.ToLower(strings.TrimSpace(line))`.
   - Accept "r" or "remove" -> return "remove".
   - Accept "k" or "keep" -> return "keep".
   - On anything else (including empty string / bare Enter): print `  Please enter 'k' to keep or 'r' to remove: ` to `out` and loop.

3. **Print a scan summary header** before starting the walkthrough: `fmt.Fprintf(out, "\nFound %d items. Review each to keep or remove:\n", totalItems)`. This gives context about the scope of the walkthrough.

Create `internal/interactive/interactive_test.go` with table-driven tests:

- **TestRunWalkthrough_RemovesMarked**: 3 entries in 1 category, user inputs "r\nk\nr\n". Verify returned slice has 1 category with 2 entries (first and third), TotalSize is sum of those two.
- **TestRunWalkthrough_AllKeep**: 2 entries, user inputs "k\nk\n". Verify returns nil.
- **TestRunWalkthrough_AllRemove**: 2 entries, user inputs "r\nr\n". Verify returns slice with all entries.
- **TestRunWalkthrough_EmptyResults**: Pass empty []CategoryResult. Verify returns nil and output contains "Nothing to clean."
- **TestRunWalkthrough_MultipleCategories**: 2 categories with entries, user removes from both. Verify both categories present in returned results.
- **TestRunWalkthrough_EOF**: 3 entries, user inputs only "r\n" (EOF after first). Verify first entry marked remove, remaining default to keep.
- **TestRunWalkthrough_InvalidInputReprompts**: Input "x\nr\n" for 1 entry. Verify output contains re-prompt text and entry is marked for removal.
- **TestRunWalkthrough_ProgressIndicator**: Verify output contains "[1/N]" and "[N/N]" format strings.
- **TestRunWalkthrough_ShorthandInput**: Test "k" and "r" shorthand alongside "keep" and "remove" full words.

Use `strings.NewReader` for input and `bytes.Buffer` for output in all tests. Use `scan.CategoryResult` and `scan.ScanEntry` types directly (no new types).
  </action>
  <verify>
Run `cd /Users/gregor/projects/mac-clarner && go test ./internal/interactive/... -v` and confirm all tests pass. Run `go vet ./internal/interactive/...` with no warnings.
  </verify>
  <done>
RunWalkthrough accepts io.Reader/io.Writer and []CategoryResult, presents items with [N/M] progress and size, accepts k/keep/r/remove input, re-prompts on invalid input, returns only marked-for-removal entries, handles empty results and all-keep gracefully, and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire interactive mode into CLI as default no-args behavior</name>
  <files>cmd/root.go</files>
  <action>
Modify `cmd/root.go`:

1. **Add import** for `"github.com/gregor/mac-cleaner/internal/interactive"` and `"bufio"`.

2. **Create `scanAll()` helper** (private function):
   ```go
   func scanAll() []scan.CategoryResult {
       var allResults []scan.CategoryResult
       if results, err := system.Scan(); err == nil && len(results) > 0 {
           printResults(results, true, "System Caches")
           allResults = append(allResults, results...)
       }
       if results, err := browser.Scan(); err == nil && len(results) > 0 {
           printResults(results, true, "Browser Data")
           allResults = append(allResults, results...)
       }
       if results, err := developer.Scan(); err == nil && len(results) > 0 {
           printResults(results, true, "Developer Caches")
           allResults = append(allResults, results...)
       }
       if results, err := appleftovers.Scan(); err == nil && len(results) > 0 {
           printResults(results, true, "App Leftovers")
           allResults = append(allResults, results...)
       }
       return allResults
   }
   ```
   Note: Always pass `dryRun: true` to `printResults` in scanAll because the interactive walkthrough handles deletion decisions -- this scan display is preview-only. If a scanner returns an error, print to stderr and continue (same as flag-based scan pattern).

3. **Replace the `!ran` branch** in the root command's Run function. Currently it calls `cmd.Help()`. Replace with:
   ```go
   if !ran {
       allResults := scanAll()
       if len(allResults) == 0 {
           fmt.Println("Nothing to clean.")
           return
       }

       reader := bufio.NewReader(os.Stdin)
       marked := interactive.RunWalkthrough(reader, os.Stdout, allResults)
       if marked == nil {
           return
       }

       if flagDryRun {
           return
       }

       if !confirm.PromptConfirmation(reader, os.Stdout, marked) {
           fmt.Println("Aborted.")
           return
       }
       result := cleanup.Execute(marked)
       printCleanupSummary(result)
   }
   ```

   **Critical: shared bufio.Reader.** Create ONE `bufio.Reader` from `os.Stdin` and pass it to BOTH `interactive.RunWalkthrough` (as the `io.Reader` parameter) and `confirm.PromptConfirmation` (as the `io.Reader` parameter). Since `*bufio.Reader` implements `io.Reader`, both functions accept it. The confirm package internally calls `bufio.NewReader(in)` which, when `in` is already a `*bufio.Reader` with sufficient buffer, returns the same instance (Go's bufio optimization). This prevents the buffered-data-loss pitfall identified in research.

4. **Stderr error handling in scanAll**: For each scanner, on error log to stderr with `fmt.Fprintf(os.Stderr, "Warning: %v\n", err)` and continue. Don't return nil on error -- just skip that scanner's results. This ensures partial scans still work.
  </action>
  <verify>
Run `cd /Users/gregor/projects/mac-clarner && go build ./...` to verify compilation. Run `go vet ./...` with no warnings. Run `go test ./... -v` to verify all existing tests still pass. Manually verify that running `./mac-cleaner` (no args) no longer shows help text -- it should start scanning and enter interactive mode (will vary by machine state).
  </verify>
  <done>
Running `mac-cleaner` with no flags enters interactive mode: scans all categories, shows results, then walks through each item for keep/remove. A single shared bufio.Reader is used for both walkthrough and confirmation prompts. Dry-run mode runs the walkthrough but skips confirmation and deletion. All existing flag-based scan behavior is unchanged.
  </done>
</task>

</tasks>

<verification>
1. `go test ./... -v` -- all tests pass (existing + new interactive tests)
2. `go build ./...` -- compiles without errors
3. `go vet ./...` -- no warnings
4. `mac-cleaner` (no args) enters interactive mode, not help
5. `mac-cleaner --system-caches --dry-run` still works as before (flag-based mode unchanged)
6. `mac-cleaner --dry-run` (no scan flags) enters interactive mode with dry-run banner
</verification>

<success_criteria>
- internal/interactive package exists with RunWalkthrough and tests
- No-args invocation enters interactive walkthrough mode
- Each item shown with [N/M] progress indicator, description, and formatted size
- k/keep and r/remove accepted, invalid input re-prompts
- Final confirmation via existing confirm.PromptConfirmation before deletion
- Cleanup via existing cleanup.Execute with summary output
- Shared bufio.Reader prevents buffered data loss between walkthrough and confirmation
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-interactive-mode/05-01-SUMMARY.md`
</output>
