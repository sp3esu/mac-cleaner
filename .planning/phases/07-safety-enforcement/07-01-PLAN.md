---
phase: 07-safety-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/scan/types.go
  - internal/safety/risk.go
  - internal/safety/risk_test.go
  - internal/scan/helpers.go
  - pkg/system/scanner.go
  - pkg/browser/scanner.go
  - pkg/developer/scanner.go
  - pkg/appleftovers/scanner.go
autonomous: true

must_haves:
  truths:
    - "Every ScanEntry produced by every scanner has a non-empty RiskLevel field"
    - "Risk level mapping covers all 14 existing category IDs"
    - "Unknown category IDs default to moderate risk"
    - "Permission errors during scanning are collected into PermissionIssue structs on CategoryResult"
    - "Safari TCC permission denial produces a PermissionIssue instead of ad-hoc stderr print"
    - "Permission errors do not abort scanning or prevent other categories from returning results"
  artifacts:
    - path: "internal/safety/risk.go"
      provides: "Risk level constants and RiskForCategory mapping function"
      contains: "RiskForCategory"
    - path: "internal/safety/risk_test.go"
      provides: "Table-driven tests for risk mapping"
      contains: "TestRiskForCategory"
    - path: "internal/scan/types.go"
      provides: "RiskLevel field on ScanEntry, PermissionIssue type, PermissionIssues field on CategoryResult and ScanSummary"
      contains: "RiskLevel"
  key_links:
    - from: "internal/safety/risk.go"
      to: "internal/scan/types.go"
      via: "risk constants used as ScanEntry.RiskLevel values"
      pattern: "RiskSafe|RiskModerate|RiskRisky"
    - from: "pkg/*/scanner.go"
      to: "internal/safety/risk.go"
      via: "SetRiskLevels(safety.RiskForCategory) call on each CategoryResult"
      pattern: "SetRiskLevels\\(safety\\.RiskForCategory\\)"
---

<objective>
Add risk level categorization and permission error collection to all scanners.

Purpose: Every scan entry needs a risk level (safe/moderate/risky) so the display layer can warn users about dangerous deletions. Permission errors need to be collected structurally so the display layer can report what was skipped. This plan adds the types, mapping function, and scanner integration. The display layer changes come in Plan 02.

Output: All scanners produce CategoryResults with risk-tagged entries and collected PermissionIssues. Existing tests continue to pass (new fields are additive).
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-safety-enforcement/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add risk/permission types and mapping function</name>
  <files>
    internal/scan/types.go
    internal/safety/risk.go
    internal/safety/risk_test.go
  </files>
  <action>
**internal/scan/types.go** -- Add three things:

1. `RiskLevel string` field to `ScanEntry` with JSON tag `json:"risk_level"`:
```go
type ScanEntry struct {
    Path        string `json:"path"`
    Description string `json:"description"`
    Size        int64  `json:"size"`
    RiskLevel   string `json:"risk_level"`
}
```

2. `PermissionIssue` type:
```go
type PermissionIssue struct {
    Path        string `json:"path"`
    Description string `json:"description"`
}
```

3. `PermissionIssues []PermissionIssue` field on `CategoryResult` with JSON tag `json:"permission_issues,omitempty"`:
```go
type CategoryResult struct {
    Category         string            `json:"category"`
    Description      string            `json:"description"`
    Entries          []ScanEntry       `json:"entries"`
    TotalSize        int64             `json:"total_size"`
    PermissionIssues []PermissionIssue `json:"permission_issues,omitempty"`
}
```

4. `PermissionIssues []PermissionIssue` field on `ScanSummary` with JSON tag `json:"permission_issues,omitempty"`:
```go
type ScanSummary struct {
    Categories       []CategoryResult  `json:"categories"`
    TotalSize        int64             `json:"total_size"`
    PermissionIssues []PermissionIssue `json:"permission_issues,omitempty"`
}
```

5. `SetRiskLevels` method on `*CategoryResult`:
```go
func (cr *CategoryResult) SetRiskLevels(riskFn func(string) string) {
    level := riskFn(cr.Category)
    for i := range cr.Entries {
        cr.Entries[i].RiskLevel = level
    }
}
```

**internal/safety/risk.go** -- NEW file. Risk level constants and mapping function. Important: constants live here (NOT in scan package) to avoid circular import since scan/helpers.go already imports safety.

```go
package safety

const (
    RiskSafe     = "safe"
    RiskModerate = "moderate"
    RiskRisky    = "risky"
)

var categoryRisk = map[string]string{
    "system-caches":      RiskSafe,
    "system-logs":        RiskSafe,
    "quicklook":          RiskSafe,
    "browser-safari":     RiskModerate,
    "browser-chrome":     RiskModerate,
    "browser-firefox":    RiskModerate,
    "dev-xcode":          RiskRisky,
    "dev-npm":            RiskModerate,
    "dev-yarn":           RiskModerate,
    "dev-homebrew":       RiskModerate,
    "dev-docker":         RiskRisky,
    "app-orphaned-prefs": RiskRisky,
    "app-ios-backups":    RiskRisky,
    "app-old-downloads":  RiskModerate,
}

func RiskForCategory(categoryID string) string {
    if level, ok := categoryRisk[categoryID]; ok {
        return level
    }
    return RiskModerate
}
```

**internal/safety/risk_test.go** -- NEW file. Table-driven tests:
1. Test all 14 known category IDs map to expected risk levels.
2. Test unknown category ID returns "moderate".
3. Test empty string returns "moderate".

Run `go build ./...` and `go test ./internal/safety/...` to verify.
  </action>
  <verify>
`go build ./...` succeeds (no compilation errors from new fields).
`go test ./internal/safety/...` passes all risk mapping tests.
`go test ./...` passes (existing tests not broken by additive field changes).
  </verify>
  <done>
ScanEntry has RiskLevel field. CategoryResult and ScanSummary have PermissionIssues fields. SetRiskLevels method exists on CategoryResult. RiskForCategory maps all 14 categories correctly with moderate default. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate risk levels and permission collection into all scanners</name>
  <files>
    internal/scan/helpers.go
    pkg/system/scanner.go
    pkg/browser/scanner.go
    pkg/developer/scanner.go
    pkg/appleftovers/scanner.go
  </files>
  <action>
Each scanner needs two changes: (a) call `cr.SetRiskLevels(safety.RiskForCategory)` on every CategoryResult before returning, and (b) collect permission errors into `PermissionIssue` structs on the CategoryResult instead of silently swallowing them.

**internal/scan/helpers.go** -- Add import of `safety` package (already imported). In `ScanTopLevel`, detect permission errors on `os.ReadDir` and on individual entry scanning:
- If `os.ReadDir(dir)` returns a permission error, return a `*CategoryResult` with no entries but with a PermissionIssue, and nil error: `return &CategoryResult{Category: category, Description: description, PermissionIssues: []PermissionIssue{{Path: dir, Description: description + " (permission denied)"}}}, nil`
- For individual entry errors in the loop (entry.Info() or DirSize failures), check `os.IsPermission(err)` and if true, append to a local `permIssues` slice instead of just `continue`. At the end, set `cr.PermissionIssues = permIssues` on the returned CategoryResult.

**pkg/system/scanner.go** -- Add import `"github.com/gregor/mac-cleaner/internal/safety"`. After each `scan.ScanTopLevel` call and `scanQuickLook` call, add `cr.SetRiskLevels(safety.RiskForCategory)`. For permission errors in `scanQuickLook`: if `os.ReadDir(cacheParent)` returns permission error, return a CategoryResult with PermissionIssue. For individual QuickLook entry errors, collect permission issues.

**pkg/browser/scanner.go** -- Add import `"github.com/gregor/mac-cleaner/internal/safety"`. Modify `scanSafari`:
- Change return signature concept: instead of returning nil on TCC permission error, return a `*scan.CategoryResult` that has zero entries but carries PermissionIssues. Remove the ad-hoc `fmt.Fprintf(os.Stderr, ...)` TCC hint.
- After building the result, call `cr.SetRiskLevels(safety.RiskForCategory)`.

Modify `scanChrome`:
- If `os.ReadDir(chromeDir)` returns permission error, return CategoryResult with PermissionIssue.
- If `os.Stat(chromeDir)` returns permission error, return CategoryResult with PermissionIssue.
- After building result, call `cr.SetRiskLevels(safety.RiskForCategory)`.

Modify `scanFirefox`:
- If `os.Stat(firefoxDir)` returns permission error, return CategoryResult with PermissionIssue.
- After getting result from ScanTopLevel (which now handles its own permission collection), call `cr.SetRiskLevels(safety.RiskForCategory)`.

**pkg/developer/scanner.go** -- Add import `"github.com/gregor/mac-cleaner/internal/safety"`. For each scanner helper:
- `scanXcodeDerivedData`: If `os.Stat` returns permission error, return CategoryResult with PermissionIssue. After ScanTopLevel, call `cr.SetRiskLevels(safety.RiskForCategory)`.
- `scanNpmCache`: Same pattern. Permission error on Stat -> PermissionIssue.
- `scanYarnCache`: If `os.Stat` or `scan.DirSize` returns permission error, return CategoryResult with PermissionIssue. Call `cr.SetRiskLevels(safety.RiskForCategory)` before return.
- `scanHomebrew`: Same pattern as npm.
- `scanDocker`: Call `cr.SetRiskLevels(safety.RiskForCategory)` before return. No permission issue collection needed (Docker errors are CLI errors, not filesystem permission errors).

**pkg/appleftovers/scanner.go** -- Add import `"github.com/gregor/mac-cleaner/internal/safety"`. For each scanner helper:
- `scanOrphanedPrefs`: If `os.Stat(prefsDir)` or `os.ReadDir(prefsDir)` returns permission error, return CategoryResult with PermissionIssue. For individual Lstat errors on plist files, check `os.IsPermission` and collect. Call `cr.SetRiskLevels(safety.RiskForCategory)`.
- `scanIOSBackups`: If `os.Stat(backupDir)` returns permission error, return CategoryResult with PermissionIssue. After ScanTopLevel, call `cr.SetRiskLevels(safety.RiskForCategory)`.
- `scanOldDownloads`: If `os.Stat(downloadsDir)` or `os.ReadDir(downloadsDir)` returns permission error, return CategoryResult with PermissionIssue. For individual entry errors (Info(), DirSize), check `os.IsPermission` and collect. Call `cr.SetRiskLevels(safety.RiskForCategory)`.

**Important pattern for all permission-issue-only returns:** When a scanner detects a top-level permission error, return a CategoryResult with the correct Category and Description but empty Entries, zero TotalSize, and the PermissionIssue populated. The caller (each package's Scan() function) already checks `cr != nil` but does NOT check `len(cr.Entries) == 0` before appending -- so the result (with just permission issues) will propagate upward. However, some callers DO check `len(cr.Entries) == 0` and skip. For those callers, also check `len(cr.PermissionIssues) > 0` and include the result if it has permission issues even with zero entries.

Run `go build ./...` and `go test ./...`.
  </action>
  <verify>
`go build ./...` succeeds.
`go test ./...` passes. Existing scanner tests are not broken because RiskLevel defaults to empty string in test fixtures (tests don't assert on it yet -- they check paths and sizes).
Grep for `SetRiskLevels(safety.RiskForCategory)` shows at least one call per scanner package (system, browser, developer, appleftovers).
Grep for `os.IsPermission` shows permission checking in scanner error paths.
  </verify>
  <done>
All 4 scanner packages call SetRiskLevels on every CategoryResult. Safari TCC handling replaced with structured PermissionIssue (no more ad-hoc stderr prints). Each scanner collects permission errors into CategoryResult.PermissionIssues. ScanTopLevel helper also detects and collects permission errors. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors.
2. `go test ./...` passes all existing and new tests.
3. `grep -r "RiskLevel" internal/scan/types.go` shows field on ScanEntry.
4. `grep -r "PermissionIssue" internal/scan/types.go` shows type and fields on CategoryResult and ScanSummary.
5. `grep -r "SetRiskLevels" internal/scan/types.go` shows method.
6. `grep -r "RiskForCategory" internal/safety/risk.go` shows mapping function.
7. `grep -r "SetRiskLevels(safety.RiskForCategory)" pkg/` shows integration in all scanner packages.
8. No circular import errors (safety does not import scan).
</verification>

<success_criteria>
- Every CategoryResult produced by any scanner has entries with non-empty RiskLevel
- Risk mapping covers all 14 category IDs with correct safe/moderate/risky assignments
- Unknown categories default to moderate
- Permission errors are collected as PermissionIssue structs, not swallowed or printed ad-hoc
- Safari TCC error path returns PermissionIssue instead of fprintf to stderr
- All existing tests pass without modification (new fields are additive)
- No circular imports between safety and scan packages
</success_criteria>

<output>
After completion, create `.planning/phases/07-safety-enforcement/07-01-SUMMARY.md`
</output>
