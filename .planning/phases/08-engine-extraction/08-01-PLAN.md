---
phase: 08-engine-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/engine/scanner.go
  - internal/engine/registry.go
  - internal/engine/token.go
  - internal/engine/errors.go
  - internal/engine/engine.go
  - internal/engine/engine_test.go
autonomous: true

must_haves:
  truths:
    - "Engine exposes Scanner interface with Scan() and Info() methods"
    - "Engine.ScanAll() returns two channels (events + result) and respects context cancellation"
    - "Engine.Run() executes a single scanner synchronously and returns results directly"
    - "Engine.Cleanup() validates a scan token, delegates to cleanup.Execute, and streams via channels"
    - "ScanAll produces a ScanToken; Cleanup consumes it (one-time use, replay protection)"
    - "Custom error types ScanError, CancelledError, TokenError are usable with errors.As()"
    - "All 14+ existing engine tests continue to pass (or are migrated to new API)"
  artifacts:
    - path: "internal/engine/scanner.go"
      provides: "Scanner interface, ScannerInfo struct, scannerAdapter, NewScanner()"
      contains: "type Scanner interface"
    - path: "internal/engine/registry.go"
      provides: "Register(), DefaultScanners(), Categories()"
      contains: "func (e *Engine) Register"
    - path: "internal/engine/token.go"
      provides: "ScanToken type, storeResults(), validateToken(), token store"
      contains: "type ScanToken string"
    - path: "internal/engine/errors.go"
      provides: "ScanError, CancelledError, TokenError custom error types"
      contains: "type ScanError struct"
    - path: "internal/engine/engine.go"
      provides: "Engine struct, New(), ScanAll(), Run(), Cleanup(), FilterSkipped()"
      contains: "func (e *Engine) ScanAll"
    - path: "internal/engine/engine_test.go"
      provides: "Tests for all engine functionality with mock scanners"
      min_lines: 250
  key_links:
    - from: "internal/engine/engine.go"
      to: "internal/engine/scanner.go"
      via: "Engine.scanners field holds []Scanner interface"
      pattern: "scanners\\s+\\[\\]Scanner"
    - from: "internal/engine/engine.go"
      to: "internal/engine/token.go"
      via: "ScanAll calls storeResults, Cleanup calls validateToken"
      pattern: "e\\.storeResults|e\\.validateToken"
    - from: "internal/engine/engine.go"
      to: "internal/cleanup"
      via: "Cleanup delegates to cleanup.Execute"
      pattern: "cleanup\\.Execute"
    - from: "internal/engine/registry.go"
      to: "pkg/*"
      via: "DefaultScanners registers all 6 scanner packages via NewScanner adapter"
      pattern: "NewScanner.*system\\.Scan|browser\\.Scan|developer\\.Scan"
---

<objective>
Build the new engine package with Scanner interface, Engine struct, channel-based streaming, token-based cleanup validation, and custom error types. This replaces the existing package-level functions with a proper struct-based API that supports both CLI and server consumption.

Purpose: Create the shared orchestration layer that decouples scan/cleanup from cobra. The engine becomes the sole orchestrator for both CLI (Plan 02) and server (Plan 02).
Output: Complete `internal/engine/` package with Scanner interface, Engine struct, and comprehensive tests using mock scanners.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-engine-extraction/08-CONTEXT.md
@.planning/phases/08-engine-extraction/08-RESEARCH.md
@internal/engine/engine.go
@internal/engine/engine_test.go
@internal/cleanup/cleanup.go
@internal/scan/types.go
@internal/safety/risk.go
@pkg/system/scanner.go
@pkg/browser/scanner.go
@pkg/developer/scanner.go
@pkg/appleftovers/scanner.go
@pkg/creative/scanner.go
@pkg/messaging/scanner.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Scanner interface, error types, and token store</name>
  <files>
    internal/engine/scanner.go
    internal/engine/errors.go
    internal/engine/token.go
  </files>
  <action>
Create three new files in `internal/engine/`:

**scanner.go** — Scanner interface and adapter:
- Define `ScannerInfo` struct with fields: `ID string`, `Name string`, `Description string`, `CategoryIDs []string`, `RiskLevel string`. These enable the server's `categories` method to return rich metadata without extra mapping.
- Define `Scanner` interface with two methods: `Scan() ([]scan.CategoryResult, error)` and `Info() ScannerInfo`. Per user decision, this is the exact interface shape.
- Create unexported `scannerAdapter` struct with `info ScannerInfo` and `scanFn func() ([]scan.CategoryResult, error)` fields. Implement both interface methods.
- Export `NewScanner(info ScannerInfo, fn func() ([]scan.CategoryResult, error)) Scanner` constructor that returns a `*scannerAdapter`.

**errors.go** — Custom error types per user decision:
- `ScanError` struct: `ScannerID string`, `Err error`. Implement `Error() string` returning `"scanner <id>: <err>"` and `Unwrap() error` returning the inner error. This enables `errors.As()` usage by the server.
- `CancelledError` struct: `Operation string` (values: "scan" or "cleanup"). Implement `Error() string` returning `"<operation> cancelled"`.
- `TokenError` struct: `Token ScanToken`, `Reason string`. Implement `Error() string` returning `"invalid token <token>: <reason>"`.

**token.go** — Token generation and single-token store:
- Define `ScanToken` as `type ScanToken string`.
- Define unexported `tokenEntry` struct: `results []scan.CategoryResult`, `created time.Time`.
- The Engine struct (in engine.go) will hold `mu sync.Mutex` and `lastToken struct{ token ScanToken; entry *tokenEntry }` — a single-token store per research recommendation (new scan invalidates previous).
- Implement `(e *Engine) storeResults(results []scan.CategoryResult) ScanToken`: generate 16 bytes via `crypto/rand.Read`, hex-encode to string, store as the single token (replacing any previous), return the token.
- Implement `(e *Engine) validateToken(token ScanToken) ([]scan.CategoryResult, error)`: under lock, check if token matches `lastToken.token`. If not, return `&TokenError{Token: token, Reason: "unknown or expired"}`. If valid, return a COPY of the results slice (not a reference to the stored one) and clear the token store (one-time use). This prevents replay.

Use `crypto/rand` and `encoding/hex` from stdlib — no external dependencies.
  </action>
  <verify>
`go build ./internal/engine/...` compiles without errors. `go vet ./internal/engine/...` passes.
  </verify>
  <done>
Scanner interface, ScannerInfo struct, adapter pattern, three custom error types, and token store with generation/validation — all compile cleanly. No pkg/* scanner signatures are modified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite Engine struct with channel-based ScanAll, Run, Cleanup, and registry</name>
  <files>
    internal/engine/engine.go
    internal/engine/registry.go
  </files>
  <action>
**registry.go** — Registry and DefaultScanners:
- Implement `(e *Engine) Register(s Scanner)` — appends scanner to `e.scanners` slice.
- Implement `(e *Engine) Categories() []ScannerInfo` — returns Info() for all registered scanners.
- Implement `RegisterDefaults(e *Engine)` as a package-level function. This explicitly calls `e.Register(NewScanner(...))` for all 6 scanner groups:
  1. system: ID="system", Name="System Caches", Description="User caches, logs, and QuickLook thumbnails", CategoryIDs=["system-caches", "system-logs", "quicklook"], ScanFn=system.Scan
  2. browser: ID="browser", Name="Browser Data", Description="Safari, Chrome, and Firefox caches", CategoryIDs=["browser-safari", "browser-chrome", "browser-firefox"], ScanFn=browser.Scan
  3. developer: ID="developer", Name="Developer Caches", Description="Xcode, npm, yarn, Homebrew, Docker, and more", CategoryIDs=["dev-xcode", "dev-npm", "dev-yarn", "dev-homebrew", "dev-docker", "dev-pnpm", "dev-cocoapods", "dev-gradle", "dev-pip", "dev-simulator-caches", "dev-simulator-logs", "dev-xcode-device-support", "dev-xcode-archives"], ScanFn=developer.Scan
  4. appleftovers: ID="appleftovers", Name="App Leftovers", Description="Orphaned preferences, iOS backups, and old Downloads", CategoryIDs=["app-orphaned-prefs", "app-ios-backups", "app-old-downloads"], ScanFn=appleftovers.Scan
  5. creative: ID="creative", Name="Creative App Caches", Description="Adobe, Sketch, and Figma caches", CategoryIDs=["creative-adobe", "creative-adobe-media", "creative-sketch", "creative-figma"], ScanFn=creative.Scan
  6. messaging: ID="messaging", Name="Messaging App Caches", Description="Slack, Discord, Teams, and Zoom caches", CategoryIDs=["msg-slack", "msg-discord", "msg-teams", "msg-zoom"], ScanFn=messaging.Scan
- Import all 6 `pkg/*` packages. RiskLevel field in ScannerInfo can be left empty — risk is per-category, not per-scanner-group, and is already handled by `CategoryResult.SetRiskLevels`.

**engine.go** — Complete rewrite. Replace the existing package-level API with a struct-based API:

Remove the old `Scanner` struct, old `ScanAll()` package-level function, and old `ScanProgressFunc` type. Keep `FilterSkipped()` as a package-level utility (it has no Engine dependency and is already tested).

Keep the existing `ScanEvent` struct and event constants (`EventScannerStart`, `EventScannerDone`, `EventScannerError`) — they are used by both CLI and server. Add a new `CleanupEvent` struct with fields: `Type string` (constants: `EventCleanupCategoryStart = "cleanup_category_start"`, `EventCleanupEntry = "cleanup_entry"`, `EventCleanupDone = "cleanup_done"`), `Category string`, `EntryPath string`, `Current int`, `Total int`, `Result *cleanup.CleanupResult` (populated only for Done events).

Define `ScanResult` struct: `Results []scan.CategoryResult`, `Token ScanToken`.

Define `Engine` struct:
```go
type Engine struct {
    scanners  []Scanner
    mu        sync.Mutex
    lastToken struct {
        token ScanToken
        entry *tokenEntry
    }
}
```

Implement `New() *Engine` — returns Engine with empty scanners, nil lastToken.

Implement `(e *Engine) ScanAll(ctx context.Context, skip map[string]bool) (<-chan ScanEvent, <-chan ScanResult)`:
- Create `events := make(chan ScanEvent)` and `done := make(chan ScanResult, 1)`.
- Launch goroutine that:
  - `defer close(events)` then `defer close(done)`
  - Iterates scanners SEQUENTIALLY (per research recommendation: sequential for phase 8, matching current behavior)
  - For each scanner: check `ctx.Err() != nil` first, return if cancelled
  - Send `EventScannerStart` via select with `ctx.Done()` (pitfall 1 from research: ALWAYS select on sends)
  - Call `s.Scan()` — if error, send `EventScannerError` via select, continue to next scanner
  - If success, send `EventScannerDone` with results via select, append to aggregate
  - After all scanners: call `FilterSkipped(all, skip)`, call `e.storeResults(filtered)`, send `ScanResult{Results: filtered, Token: token}` on done channel
- Return both channels.

Implement `(e *Engine) Run(ctx context.Context, scannerID string) ([]scan.CategoryResult, error)`:
- Find scanner by ID in `e.scanners`. If not found, return `nil, fmt.Errorf("scanner %q not found", scannerID)`.
- Check `ctx.Err()` before calling. If cancelled, return `nil, &CancelledError{Operation: "scan"}`.
- Call `s.Scan()`. If error, return `nil, &ScanError{ScannerID: scannerID, Err: err}`.
- Return results directly (synchronous — per research recommendation for single-scanner calls).

Implement `(e *Engine) Cleanup(ctx context.Context, token ScanToken, categoryIDs []string) (<-chan CleanupEvent, <-chan cleanup.CleanupResult)`:
- Create `events := make(chan CleanupEvent)` and `done := make(chan cleanup.CleanupResult, 1)`.
- Launch goroutine that:
  - `defer close(events)` then `defer close(done)`
  - Call `e.validateToken(token)` — if error, send zero result and return (the error was already surfaced by validateToken returning a TokenError).
    Actually, since the channel API doesn't have an error path in the done channel (it returns `cleanup.CleanupResult`), handle token errors by: checking error, if token is invalid, create a `CleanupEvent` with a new type `EventCleanupError = "cleanup_error"` that carries the error, then return. Alternatively, make the done channel `chan CleanupDone` where `CleanupDone` has `Result cleanup.CleanupResult` and `Err error`. Let me simplify: define `CleanupDone` struct with `Result cleanup.CleanupResult` and `Err error`. Use `chan CleanupDone` for the done channel.
  - Filter `validatedResults` by `categoryIDs` (if non-empty). If empty categoryIDs, use all results.
  - Call `cleanup.Execute(toClean, progressFn)` where `progressFn` sends `CleanupEvent` on the events channel (using select with ctx.Done()).
  - Send `CleanupDone{Result: result}` on done channel.
- Return both channels.
- Signature: `func (e *Engine) Cleanup(ctx context.Context, token ScanToken, categoryIDs []string) (<-chan CleanupEvent, <-chan CleanupDone)`

Define `CleanupDone` struct: `Result cleanup.CleanupResult`, `Err error`.

**IMPORTANT:** Do NOT modify any files under `pkg/*/`, `internal/cleanup/`, or `internal/scan/`. The adapter pattern in `NewScanner` wraps existing `Scan()` functions without changing them.

**IMPORTANT:** The existing `DefaultScanners()` function name is reused as `RegisterDefaults()` instead. The old `DefaultScanners() []Scanner` (returning old struct type) must be removed. If the server or CLI calls `engine.DefaultScanners()`, those call sites break intentionally — Plan 02 fixes them.
  </action>
  <verify>
`go build ./internal/engine/...` compiles. `go vet ./internal/engine/...` passes. Note: `go build ./internal/server/...` and `go build ./cmd/...` will FAIL at this point — that is expected and will be fixed in Plan 02.
  </verify>
  <done>
Engine struct with New(), Register(), Categories(), ScanAll() (channel-based, context-aware), Run() (synchronous), Cleanup() (channel-based with token validation), and RegisterDefaults() all compile. FilterSkipped() preserved as package-level utility. Old package-level ScanAll() and old Scanner struct are removed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write comprehensive engine tests with mock scanners</name>
  <files>
    internal/engine/engine_test.go
  </files>
  <action>
Rewrite `engine_test.go` to test the new struct-based API. All 14 existing test scenarios must be covered (migrated to new API), plus new tests for the added functionality. Use mock scanners created via `NewScanner()`.

**Helper:** Create `mockScanner(id, name string, results []scan.CategoryResult, err error) Scanner` that returns `NewScanner(ScannerInfo{ID: id, Name: name}, fn)`.

**Migrate existing tests (update API calls):**
1. `TestRegisterDefaults_Count` — `RegisterDefaults` produces 6 scanners (via `eng.Categories()`)
2. `TestRegisterDefaults_UniqueIDs` — all scanner IDs are unique
3. `TestRegisterDefaults_HaveNames` — all scanners have non-empty Names
4. `TestRegisterDefaults_HaveScanFn` — verify by calling `Run()` (it won't panic)
5. `TestScanAll_AggregatesResults` — use `eng.ScanAll(ctx, nil)`, drain events channel, read result from done channel, verify 3 categories
6. `TestScanAll_SkipsErroredScanners` — verify errored scanner skipped, 2 results returned
7. `TestScanAll_AppliesSkipSet` — verify skip filtering works via done channel result
8. `TestScanAll_ProgressEvents` — collect events from events channel, verify start/done/error sequence
9. `TestScanAll_EmptyScanners` — engine with no scanners returns 0 results
10. `TestFilterSkipped_*` — 5 tests unchanged (FilterSkipped is still package-level)

**New tests:**
11. `TestScanAll_ContextCancellation` — register a scanner that blocks on a channel. Cancel context. Verify events channel closes without hanging. Use `time.After` to prevent test hanging.
12. `TestScanAll_ProducesToken` — verify ScanResult.Token is non-empty after ScanAll completes.
13. `TestRun_SingleScanner` — register 2 scanners, call `Run(ctx, "a")`, verify only scanner "a" results returned.
14. `TestRun_ScannerNotFound` — call `Run(ctx, "nonexistent")`, verify error returned.
15. `TestRun_PropagatesError` — register scanner that errors, verify `errors.As(&ScanError{})` works.
16. `TestCleanup_ValidToken` — run ScanAll, get token, call Cleanup with that token and empty categoryIDs. Verify CleanupDone has no error. (Note: actual file deletion won't happen because mock scan results have no real paths — cleanup.Execute will report failures for non-existent paths, which is fine for testing the plumbing.)
17. `TestCleanup_InvalidToken` — call Cleanup with a fake token, verify CleanupDone.Err is a `*TokenError` via `errors.As`.
18. `TestCleanup_TokenConsumed` — scan, cleanup with valid token, cleanup again with same token, verify second call gets TokenError (replay protection).
19. `TestCleanup_PartialCategories` — scan produces categories ["a-1", "b-1"], cleanup with categoryIDs=["a-1"] only, verify only "a-1" is cleaned.
20. `TestCategories_ReturnsRegisteredInfo` — register 2 scanners, verify Categories() returns correct ScannerInfo for each.
21. `TestEngine_Register` — verify Register adds scanners correctly.
22. `TestScanAll_ContextCancelDuringScan` — register scanner whose Scan() checks a context indirectly (scanner itself doesn't take context, but after scanner returns, the event send respects cancellation). Cancel during iteration, verify channel closes.
23. `TestCleanup_ContextCancellation` — cancel context during cleanup, verify channels close.
24. `TestStoreResults_SingleTokenPolicy` — call storeResults twice, verify first token is invalidated.

Use `context.Background()` for non-cancellation tests. Use `context.WithCancel()` for cancellation tests. Always drain both channels in tests to prevent goroutine leaks. Use `t.Helper()` for helper functions.

Run `go test -race ./internal/engine/...` to verify no data races (especially around token store mutex).
  </action>
  <verify>
`go test -race -count=1 ./internal/engine/...` passes with all tests green. `go vet ./internal/engine/...` clean.
  </verify>
  <done>
24+ tests covering: scanner interface + adapter, Engine struct lifecycle, ScanAll channel streaming + context cancellation + skip filtering + token production, Run synchronous execution + error wrapping, Cleanup token validation + replay protection + partial categories + context cancellation, FilterSkipped utility, Categories metadata, Register. All pass with -race flag.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/engine/...` compiles
2. `go vet ./internal/engine/...` is clean
3. `go test -race -count=1 ./internal/engine/...` — all tests pass
4. `go build ./cmd/...` will FAIL (expected — Plan 02 fixes server + CLI)
5. Engine package has zero cobra dependency: `grep -r "cobra" internal/engine/` returns nothing
6. Engine package has zero fmt.Print to stdout: `grep -r "fmt.Print" internal/engine/` returns nothing (only in tests if needed)
</verification>

<success_criteria>
- Engine package compiles independently with no cobra dependency
- Scanner interface + ScannerInfo provide rich metadata for server categories
- ScanAll returns channels, respects context, produces token
- Run provides synchronous single-scanner execution
- Cleanup validates token (one-time use), delegates to cleanup.Execute, streams events
- Custom error types work with errors.As()
- 24+ tests pass with -race flag
- FilterSkipped preserved as utility function
- RegisterDefaults registers all 6 scanner groups with full metadata
</success_criteria>

<output>
After completion, create `.planning/phases/08-engine-extraction/08-01-SUMMARY.md`
</output>
