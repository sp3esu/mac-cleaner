---
phase: 08-engine-extraction
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - cmd/root.go
  - cmd/root_test.go
  - cmd/serve.go
  - internal/server/server.go
  - internal/server/handler.go
  - internal/server/handler_scan.go
  - internal/server/handler_cleanup.go
  - internal/server/server_test.go
autonomous: true

must_haves:
  truths:
    - "CLI behavior is identical: `mac-cleaner --all --dry-run` output is unchanged"
    - "CLI interactive mode (no flags) works identically through the engine"
    - "CLI flag-based scanning delegates to engine instead of calling pkg/* directly"
    - "Server uses Engine struct instance instead of package-level engine functions"
    - "Server scan handler uses Engine.ScanAll() channel API"
    - "Server cleanup handler uses Engine.Cleanup() with token validation"
    - "All existing tests pass: `go test ./...` is green"
  artifacts:
    - path: "cmd/root.go"
      provides: "CLI using Engine struct for all scanning and cleanup"
      contains: "engine.New()"
    - path: "cmd/serve.go"
      provides: "Serve command passing Engine to server"
      contains: "engine.RegisterDefaults"
    - path: "internal/server/server.go"
      provides: "Server holding *engine.Engine instance"
      contains: "*engine.Engine"
    - path: "internal/server/handler_scan.go"
      provides: "Scan handler using Engine.ScanAll() channel API"
      contains: "e.engine.ScanAll"
    - path: "internal/server/handler_cleanup.go"
      provides: "Cleanup handler using Engine.Cleanup() with token"
      contains: "e.engine.Cleanup"
  key_links:
    - from: "cmd/root.go"
      to: "internal/engine"
      via: "Creates Engine, calls ScanAll/Run, drains channels"
      pattern: "eng\\.ScanAll|eng\\.Run|engine\\.RegisterDefaults"
    - from: "cmd/serve.go"
      to: "internal/server"
      via: "Creates Engine, passes to server.New()"
      pattern: "server\\.New.*eng"
    - from: "internal/server/server.go"
      to: "internal/engine"
      via: "Server holds *engine.Engine field"
      pattern: "engine\\s+\\*engine\\.Engine"
    - from: "internal/server/handler_scan.go"
      to: "internal/engine"
      via: "Drains ScanAll channels, maps events to NDJSON progress"
      pattern: "ScanAll|ScanEvent|ScanResult"
    - from: "internal/server/handler_cleanup.go"
      to: "internal/engine"
      via: "Calls Cleanup with token, drains channels"
      pattern: "Cleanup.*Token|CleanupEvent|CleanupDone"
---

<objective>
Wire `cmd/root.go` and `internal/server/` to use the new Engine struct API, removing all direct `pkg/*` scanner calls from the CLI and all package-level engine calls from the server. Verify zero behavior change with golden output comparison.

Purpose: Complete the migration so the engine is the sole orchestrator for both CLI and server. After this plan, `cmd/root.go` no longer imports any `pkg/*` scanner package, and the server no longer uses `atomic.Pointer` for scan results (the engine's token store handles replay protection).
Output: Updated CLI and server files, golden output test files in `cmd/testdata/`, all tests passing.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-engine-extraction/08-CONTEXT.md
@.planning/phases/08-engine-extraction/08-RESEARCH.md
@.planning/phases/08-engine-extraction/08-01-SUMMARY.md
@cmd/root.go
@cmd/root_test.go
@cmd/serve.go
@internal/server/server.go
@internal/server/handler.go
@internal/server/handler_scan.go
@internal/server/handler_cleanup.go
@internal/server/server_test.go
@internal/engine/engine.go
@internal/engine/scanner.go
@internal/engine/registry.go
@internal/engine/token.go
@internal/engine/errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor cmd/root.go to use Engine struct and capture golden output</name>
  <files>
    cmd/root.go
    cmd/serve.go
  </files>
  <action>
**FIRST — Before modifying cmd/root.go, capture golden output for regression testing.**

Run the existing binary to capture current output. Since scanners hit real filesystem paths, the golden output will vary per machine. Instead, create a golden output test that uses the engine with mock scanners to produce deterministic output. The golden test will be written in Task 2. For now, focus on the refactoring.

**Refactor cmd/root.go:**

1. **Remove all `pkg/*` imports.** After refactoring, `cmd/root.go` should NOT import `system`, `browser`, `developer`, `appleftovers`, `creative`, or `messaging` packages. These are now registered via `engine.RegisterDefaults()`.

2. **Create the engine in the root command's Run function** (or a package-level var initialized in init or PreRun). The simplest approach per the codebase pattern:
   - Add `var eng *engine.Engine` at package level.
   - In `PreRun` (which already exists for --all expansion), add engine initialization:
     ```go
     eng = engine.New()
     engine.RegisterDefaults(eng)
     ```

3. **Replace the 6 `runXxxScan()` functions** (runSystemCachesScan, runBrowserDataScan, runDevCachesScan, runAppLeftoversScan, runCreativeCachesScan, runMessagingCachesScan) with a single generic function:
   ```go
   func runScannerByID(scannerID string, sp *spinner.Spinner) []scan.CategoryResult {
       info := findScannerInfo(scannerID)
       sp.UpdateMessage("Scanning " + strings.ToLower(info.Name) + "...")
       sp.Start()
       results, err := eng.Run(context.Background(), scannerID)
       sp.Stop()
       if err != nil {
           fmt.Fprintf(os.Stderr, "Error: %v\n", err)
           return nil
       }
       if !flagJSON {
           printResults(results, flagDryRun, info.Name)
       }
       return results
   }
   ```
   Where `findScannerInfo` looks up scanner metadata from `eng.Categories()`.

4. **Replace the flag-based scanning block** (lines 102-125) with scanner ID mappings:
   ```go
   type scannerMapping struct {
       flag      *bool
       scannerID string
   }
   flagScanners := []scannerMapping{
       {&flagSystemCaches, "system"},
       {&flagBrowserData, "browser"},
       {&flagDevCaches, "developer"},
       {&flagAppLeftovers, "appleftovers"},
       {&flagCreativeCaches, "creative"},
       {&flagMessagingCaches, "messaging"},
   }
   for _, m := range flagScanners {
       if *m.flag {
           allResults = append(allResults, runScannerByID(m.scannerID, sp)...)
           ran = true
       }
   }
   ```

5. **Replace the `scanAll()` function** to use the new channel-based API:
   ```go
   func scanAll(sp *spinner.Spinner) []scan.CategoryResult {
       events, done := eng.ScanAll(context.Background(), nil)
       for event := range events {
           switch event.Type {
           case engine.EventScannerStart:
               sp.UpdateMessage("Scanning " + strings.ToLower(event.Label) + "...")
               sp.Start()
           case engine.EventScannerDone:
               sp.Stop()
               if len(event.Results) > 0 {
                   printResults(event.Results, true, event.Label)
               }
           case engine.EventScannerError:
               sp.Stop()
               fmt.Fprintf(os.Stderr, "Warning: %v\n", event.Err)
           }
       }
       result := <-done
       return result.Results
   }
   ```
   Note: The token from `result.Token` is not needed by the CLI interactive mode (which handles cleanup separately). The CLI still calls `cleanup.Execute` directly for now — the engine's `Cleanup()` method with token is primarily for the server. The CLI's cleanup flow (with interactive confirmation) is CLI-specific UI logic that stays in cmd/root.go.

6. **Remove the `filterSkipped()` wrapper** (line 440-442) and call `engine.FilterSkipped()` directly at the call sites. This is a minor cleanup.

7. **Update `buildSkipSet()`** — no changes needed, it already returns `map[string]bool`.

**Refactor cmd/serve.go:**

Update to create an engine and pass it to the server:
```go
eng := engine.New()
engine.RegisterDefaults(eng)
srv := server.New(flagSocket, version, eng)
```

This requires updating `server.New()` signature (done in Task 2).
  </action>
  <verify>
`go build ./cmd/...` compiles. `grep -r "pkg/system\|pkg/browser\|pkg/developer\|pkg/appleftovers\|pkg/creative\|pkg/messaging" cmd/root.go` returns nothing (no direct pkg/* imports).
  </verify>
  <done>
cmd/root.go delegates ALL scanning to engine.Run() (flag-based) and engine.ScanAll() (interactive). No direct pkg/* imports. cmd/serve.go creates and passes engine to server. Six run*Scan functions replaced by one generic function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update server to use Engine struct instance and token-based cleanup</name>
  <files>
    internal/server/server.go
    internal/server/handler.go
    internal/server/handler_scan.go
    internal/server/handler_cleanup.go
    internal/server/server_test.go
  </files>
  <action>
**server.go:**
1. Add `engine *engine.Engine` field to `Server` struct (imported from `internal/engine`).
2. Update `New()` signature to accept engine: `func New(socketPath, version string, eng *engine.Engine) *Server`. Store `eng` in the server struct.
3. REMOVE the `lastScan` field with `atomic.Pointer[[]scan.CategoryResult]` — replay protection is now handled by the engine's token store.
4. Keep the `busy` atomic — the server still needs to reject concurrent operations at the server level (this is SRV-03, phase 10 requirement, but it already exists).

**handler.go:**
- No structural changes needed. Handler still accesses `h.server` which now has the engine.

**handler_scan.go:**
1. Replace `engine.ScanAll(engine.DefaultScanners(), skip, func(e engine.ScanEvent) {...})` with the new channel-based API:
   ```go
   events, done := h.server.engine.ScanAll(ctx, skip)
   // Drain events channel, streaming progress to client
   for event := range events {
       if ctx.Err() != nil {
           break
       }
       progress := ScanProgress{ScannerID: event.ScannerID, Label: event.Label}
       switch event.Type {
       case engine.EventScannerStart:
           progress.Event = "scanner_start"
       case engine.EventScannerDone:
           progress.Event = "scanner_done"
       case engine.EventScannerError:
           progress.Event = "scanner_error"
           if event.Err != nil {
               progress.Error = event.Err.Error()
           }
       }
       _ = w.WriteProgress(req.ID, progress)
   }
   result := <-done
   ```
2. Remove `h.server.lastScan.results.Store(&results)` — the engine's token store handles this.
3. Add the scan token to the ScanResult response so the client can use it for cleanup:
   - Update the `ScanResult` struct to include `Token string `json:"token"`` field.
   - Set `Token: string(result.Token)` in the response.
4. Update `handleCategories` to use `h.server.engine.Categories()` instead of `engine.DefaultScanners()`:
   ```go
   infos := h.server.engine.Categories()
   cats := make([]CategoryInfo, len(infos))
   for i, info := range infos {
       cats[i] = CategoryInfo{ID: info.ID, Label: info.Name}
   }
   ```

**handler_cleanup.go:**
1. Replace the `lastResults` atomic.Pointer pattern with engine's token-based cleanup.
2. Add a `Token` field to `CleanupParams`: `Token string `json:"token"``.
3. Call `h.server.engine.Cleanup(ctx, engine.ScanToken(params.Token), params.Categories)`:
   ```go
   events, done := h.server.engine.Cleanup(ctx, engine.ScanToken(params.Token), params.Categories)
   for event := range events {
       if ctx.Err() != nil {
           break
       }
       _ = w.WriteProgress(req.ID, CleanupProgress{
           Event:     event.Type,
           Category:  event.Category,
           EntryPath: event.EntryPath,
           Current:   event.Current,
           Total:     event.Total,
       })
   }
   result := <-done
   if result.Err != nil {
       _ = w.WriteErrorMsg(req.ID, result.Err.Error())
       return
   }
   ```
4. Remove the `h.server.lastScan.results.Store(nil)` line — token consumption is handled by the engine.
5. If token is empty in params, return error: `"token is required; run scan first"`.

**server_test.go:**
- Update any tests that construct a `Server` via `New()` to pass an engine instance:
  ```go
  eng := engine.New()
  engine.RegisterDefaults(eng)
  srv := server.New(socketPath, version, eng)
  ```
- Update any cleanup tests to include a token in the cleanup request params.
- If tests used `srv.lastScan.results.Store(...)` to set up scan state, replace with: run a scan first via the handler to populate the engine's token store, then use the returned token in cleanup requests.

**IMPORTANT:** The CleanupParams.Token field is a protocol change. The server's NDJSON contract now requires clients to pass the scan token when requesting cleanup. This is the intended behavior per user decision (token-based replay protection). Update `docs/swift-integration.md` if it exists and references the cleanup params format. Check if it needs updating.
  </action>
  <verify>
`go build ./...` compiles. `go test ./...` all pass. `go vet ./...` clean. `go test -race ./...` no races.
  </verify>
  <done>
Server uses Engine struct instance. Scan handler uses channel-based ScanAll, includes token in response. Cleanup handler requires token parameter, delegates to Engine.Cleanup(). atomic.Pointer scan result store removed from server. All existing server tests updated and passing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify zero behavior change and add golden output regression test</name>
  <files>
    cmd/root_test.go
    cmd/testdata/
  </files>
  <action>
**Verify existing tests pass:**
Run `go test -race -count=1 ./...` and confirm all packages pass. This is the primary verification that no behavior changed.

**Add golden output regression test in cmd/root_test.go:**

The goal is to verify that the engine-based scanning produces the same output format as before. Since actual scan results depend on the machine's filesystem, create a test that:

1. Creates a mock-able test by using the engine with controlled inputs. However, since `cmd/root.go` initializes the engine internally, and the real scanners hit the filesystem, the golden test needs to either:
   a. Test the formatting functions directly with known data (simpler, deterministic), OR
   b. Inject a test engine (requires exposing the engine var for testing)

Option (a) is simpler and more reliable. Create golden output tests for the formatting functions that are the most likely to break:

```go
func TestPrintResults_GoldenOutput(t *testing.T) {
    color.NoColor = true
    defer func() { color.NoColor = false }()

    results := []scan.CategoryResult{
        {
            Category:    "test-cache",
            Description: "Test Caches",
            Entries: []scan.ScanEntry{
                {Path: "/Users/test/Library/Caches/test", Description: "Test Cache", Size: 1500000},
            },
            TotalSize: 1500000,
        },
    }

    var buf bytes.Buffer
    // Capture stdout for printResults
    // ... redirect os.Stdout to buf, call printResults, restore
    // Compare against golden file
}
```

Actually, the most valuable golden test is an integration test that verifies the engine's ScanAll channel-based flow produces the same event sequence as the old callback-based flow. Since Plan 01 already tests the engine extensively, focus here on:

1. **Test that buildSkipSet still works correctly** — already tested if existing cmd tests pass.
2. **Test that the flag-to-scanner-ID mapping is correct** — add a test that verifies each flag maps to the right scanner ID:
   ```go
   func TestFlagScannerMappings(t *testing.T) {
       // Verify all 6 scanner IDs exist in the engine
       eng := engine.New()
       engine.RegisterDefaults(eng)
       cats := eng.Categories()
       ids := map[string]bool{}
       for _, c := range cats {
           ids[c.ID] = true
       }
       expected := []string{"system", "browser", "developer", "appleftovers", "creative", "messaging"}
       for _, id := range expected {
           if !ids[id] {
               t.Errorf("expected scanner ID %q not found in engine", id)
           }
       }
   }
   ```
3. **Run the full CLI with `--all --dry-run` and verify it completes without error.** This is the most important smoke test — it exercises the entire ScanAll channel-draining path on the real filesystem.
4. **Test that `--json --all` still produces valid JSON output** — parse the output with `json.Unmarshal` into `scan.ScanSummary`.

**Run final verification:**
```bash
go test -race -count=1 ./...
go vet ./...
gosec ./...
```

If `gosec` reports any issues in the new/modified code, fix them.

**Build and smoke test:**
```bash
go build -o /tmp/mac-cleaner-test .
/tmp/mac-cleaner-test --all --dry-run 2>&1 | head -50
```
Verify the output looks normal (categories listed, sizes shown, "dry run" in headers).
  </action>
  <verify>
`go test -race -count=1 ./...` all pass. `go vet ./...` clean. `gosec ./...` zero issues. `go build -o /tmp/mac-cleaner-test . && /tmp/mac-cleaner-test --all --dry-run` produces expected output with category headers, sizes, and dry-run summary.
  </verify>
  <done>
All tests pass across all packages. CLI output with --all --dry-run is visually identical to pre-refactor output. JSON output is valid. gosec clean. No direct pkg/* imports in cmd/root.go. Engine is the sole orchestrator for both CLI and server.
  </done>
</task>

</tasks>

<verification>
1. `go test -race -count=1 ./...` — ALL packages pass (engine, cmd, server, cleanup, scan, safety, all pkg/*)
2. `go vet ./...` — clean
3. `gosec ./...` — zero issues
4. `go build -o /tmp/mac-cleaner-test .` — compiles
5. `/tmp/mac-cleaner-test --all --dry-run` — produces expected output
6. `/tmp/mac-cleaner-test --json --all --dry-run` — produces valid JSON
7. `grep -r "pkg/system\|pkg/browser\|pkg/developer\|pkg/appleftovers\|pkg/creative\|pkg/messaging" cmd/root.go` — returns nothing
8. `grep -r "cobra" internal/engine/` — returns nothing
9. `grep -r "atomic.Pointer" internal/server/server.go` — returns nothing (removed)
10. Engine package is independently usable: `go build ./internal/engine/...` succeeds without any cmd/ or server/ dependency
</verification>

<success_criteria>
- CLI behavior identical: --all --dry-run output unchanged, interactive mode works, JSON output valid
- cmd/root.go has zero pkg/* scanner imports — all scanning goes through engine
- Server uses Engine struct instance, scan returns token, cleanup requires token
- Server's atomic.Pointer scan result store replaced by engine's token store
- All existing tests pass (no regressions)
- gosec clean, go vet clean, no races
</success_criteria>

<output>
After completion, create `.planning/phases/08-engine-extraction/08-02-SUMMARY.md`
</output>
