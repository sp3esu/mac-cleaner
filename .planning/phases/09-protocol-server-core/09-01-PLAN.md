---
phase: 09-protocol-server-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/server/server_test.go
  - .planning/REQUIREMENTS.md
autonomous: true

must_haves:
  truths:
    - "mac-cleaner serve --socket /tmp/test.sock starts and listens on a Unix domain socket"
    - "ping method responds with status ok and version string"
    - "Server shuts down cleanly on SIGINT/SIGTERM and via shutdown method"
    - "Stale socket files are detected and cleaned up on startup"
    - "All Phase 9 requirements are verified complete with test evidence"
  artifacts:
    - path: "internal/server/protocol.go"
      provides: "Request/Response types, NDJSONReader/Writer, method constants"
      contains: "type Request struct"
    - path: "internal/server/server.go"
      provides: "UDS listener, graceful shutdown, stale socket cleanup"
      contains: "func (s *Server) Serve"
    - path: "cmd/serve.go"
      provides: "serve subcommand with --socket flag"
      contains: "serveCmd"
    - path: "internal/server/server_test.go"
      provides: "Integration tests for server lifecycle and all handlers"
      min_lines: 480
    - path: "internal/server/protocol_test.go"
      provides: "Unit tests for NDJSON encoding/decoding"
      min_lines: 150
    - path: ".planning/REQUIREMENTS.md"
      provides: "Updated requirement status tracking"
      contains: "complete"
  key_links:
    - from: "cmd/serve.go"
      to: "internal/server/server.go"
      via: "server.New() and srv.Serve(ctx)"
      pattern: "server\\.New\\("
    - from: "internal/server/server.go"
      to: "internal/server/handler.go"
      via: "Handler.Dispatch() in connection loop"
      pattern: "s\\.handler\\.Dispatch"
    - from: "internal/server/handler.go"
      to: "internal/server/protocol.go"
      via: "NDJSONWriter for response encoding"
      pattern: "NDJSONWriter"
---

<objective>
Verify and close Phase 9 requirements (PROTO-01, SRV-01, SRV-02, SRV-04) which were proactively implemented during Phase 8 engine extraction work.

Purpose: All four Phase 9 deliverables already exist with tests. This plan audits the implementation against each requirement, adds a unit test for the cleanStaleSocket paths that are skipped in macOS integration tests, and updates REQUIREMENTS.md to reflect the actual status of Phase 8 and Phase 9 requirements.

Output: Verified Phase 9 requirements, supplemental test coverage, updated REQUIREMENTS.md
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-protocol-server-core/09-RESEARCH.md
@.planning/phases/08-engine-extraction/08-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unit test for cleanStaleSocket code paths</name>
  <files>internal/server/server_test.go</files>
  <action>
Add a unit test `TestCleanStaleSocket_Paths` that exercises the cleanStaleSocket() method without relying on platform-specific socket file behavior. The existing `TestServer_StaleSocketCleanup` is skipped on macOS because `net.Listener.Close()` removes the socket file.

The new test should cover:
1. **No file at path** -- call cleanStaleSocket on a non-existent path, expect nil error (early return path at server.go:189-191)
2. **Non-socket file at path** -- create a regular file at the socket path, expect error containing "not a socket" (server.go:197-199). Note: this path IS covered by TestServer_NonSocketFileBlocks, but testing it directly on cleanStaleSocket is cleaner.
3. **Active server at path** -- start a net.Listen("unix", path) in the test, then call cleanStaleSocket with that path, expect error containing "already listening" (server.go:202-206). Close the listener after the assertion.

Each sub-test uses t.Run for clear identification. Use t.TempDir() for all paths.

Do NOT duplicate existing integration tests. This is a focused unit test for the private method via the public Server type (create a Server with New(), then the test calls srv.Serve which calls cleanStaleSocket internally -- OR expose the behavior via the Serve method). Since cleanStaleSocket is unexported, test it indirectly: for case 3, create a listener at the path first, then call srv.Serve() and check the returned error. For cases 1-2, the existing tests already cover these.

Revised approach: Only add case 3 (active server detection) since cases 1 and 2 are already covered. Create a test `TestServer_ActiveServerBlocks` that:
1. Starts a net.Listen("unix", socketPath) to simulate an active server
2. Creates a new Server with that same socketPath
3. Calls srv.Serve(ctx) and expects the returned error to contain "already listening"
4. Cleans up the test listener

This test works on all platforms because it does not depend on socket files surviving Close().
  </action>
  <verify>
Run `go test ./internal/server/... -v -run TestServer_ActiveServerBlocks` -- test passes.
Run `go test ./internal/server/... -v -count=1` -- all existing tests still pass, new test passes.
Run `go vet ./internal/server/...` -- no issues.
Run `gosec ./internal/server/...` -- zero issues.
  </verify>
  <done>TestServer_ActiveServerBlocks passes on macOS, covering the "another server already listening" path of cleanStaleSocket that was not directly tested. All 21+ server tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update REQUIREMENTS.md with Phase 8 and Phase 9 completion status</name>
  <files>.planning/REQUIREMENTS.md</files>
  <action>
Update REQUIREMENTS.md to reflect the actual implementation status:

**Phase 8 (Engine) -- all complete:**
- ENG-01: complete -- internal/engine/engine.go, scanner.go, registry.go
- ENG-02: complete -- ScanAll() streams ScanEvent with per-scanner progress
- ENG-03: complete -- FilterSkipped() in engine package
- ENG-04: complete -- cmd/root.go uses Engine exclusively, zero pkg/* imports

**Phase 9 (Protocol) -- PROTO-01 complete:**
- PROTO-01: complete -- internal/server/protocol.go with Request/Response types, NDJSONReader/Writer, 9 unit tests

**Phase 9 (Server) -- all complete:**
- SRV-01: complete -- internal/server/server.go with Serve(), Shutdown(), context cancellation
- SRV-02: complete -- cmd/serve.go with --socket flag, SIGINT/SIGTERM handling
- SRV-04: complete -- cleanStaleSocket() with type check + dial probe, cleanup() on shutdown

Keep PROTO-02 through PROTO-05, SRV-03, and HARD-01 through HARD-03 as "pending" (those are Phase 10 and 11).

Update the status column from "pending" to "complete" for the 8 requirements listed above. Do not change any other content or formatting.
  </action>
  <verify>
Read .planning/REQUIREMENTS.md and confirm:
- All 4 ENG-* rows show "complete"
- PROTO-01 shows "complete"
- SRV-01, SRV-02, SRV-04 show "complete"
- PROTO-02 through PROTO-05, SRV-03, HARD-01 through HARD-03 still show "pending"
  </verify>
  <done>REQUIREMENTS.md accurately reflects implementation status: 8 requirements marked complete (ENG-01 through ENG-04, PROTO-01, SRV-01, SRV-02, SRV-04), remaining 8 requirements still pending for Phases 10-11.</done>
</task>

</tasks>

<verification>
1. `go test ./internal/server/... -v -count=1` -- all tests pass including new TestServer_ActiveServerBlocks
2. `go test ./... -count=1` -- full project test suite passes (170+ tests)
3. `go vet ./...` -- clean
4. `gosec ./...` -- zero issues
5. REQUIREMENTS.md has correct status for all 16 requirements
</verification>

<success_criteria>
- New test covers the "active server blocks startup" path that was not directly tested
- All server tests pass (21+), no regressions
- REQUIREMENTS.md reflects actual status: 8 complete (Phases 8-9), 8 pending (Phases 10-11)
- Full project test suite passes
- gosec and go vet clean
</success_criteria>

<output>
After completion, create `.planning/phases/09-protocol-server-core/09-01-SUMMARY.md`
</output>
