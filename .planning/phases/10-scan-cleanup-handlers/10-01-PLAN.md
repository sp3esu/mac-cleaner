---
phase: 10-scan-cleanup-handlers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/server/server_test.go
  - docs/swift-integration.md
  - .planning/REQUIREMENTS.md
autonomous: true

must_haves:
  truths:
    - "Scan request through socket produces streaming progress events (scanner_start, scanner_done) followed by a final result with categories, total_size, and token"
    - "Scan-then-cleanup flow through socket works end-to-end: scan returns token, cleanup with that token produces progress events and final result"
    - "Concurrent scan requests are rejected with a clear error message"
    - "Scan skip parameter filters categories from results when sent through socket"
    - "Swift integration docs match the actual wire format for cleanup progress events"
    - "All Phase 10 requirements are marked complete in REQUIREMENTS.md"
  artifacts:
    - path: "internal/server/server_test.go"
      provides: "Integration tests for scan streaming, scan-then-cleanup, concurrent rejection, scan with skip"
      contains: "TestServer_ScanStreaming"
    - path: "docs/swift-integration.md"
      provides: "Corrected cleanup progress event names matching Go implementation"
      contains: "cleanup_category_start"
    - path: ".planning/REQUIREMENTS.md"
      provides: "Updated requirement statuses for Phase 10"
      contains: "complete"
  key_links:
    - from: "internal/server/server_test.go"
      to: "internal/server/handler_scan.go"
      via: "socket-level integration test sends scan request and reads NDJSON responses"
      pattern: "MethodScan"
    - from: "internal/server/server_test.go"
      to: "internal/server/handler_cleanup.go"
      via: "socket-level integration test sends cleanup request with token from prior scan"
      pattern: "MethodCleanup"
    - from: "docs/swift-integration.md"
      to: "internal/server/handler_cleanup.go"
      via: "CleanupProgress event field names must match documentation"
      pattern: "cleanup_category_start"
---

<objective>
Verify and close Phase 10 requirements (scan, cleanup, categories handlers with streaming progress) by adding integration tests for the 4 untested streaming flows and fixing the Swift documentation naming discrepancy.

Purpose: All handler code was implemented during Phase 8 (engine wiring). The gap is test coverage for streaming handler flows through the socket, and a naming mismatch between Go's cleanup event types and the Swift integration docs.

Output: 4 new integration tests in server_test.go, corrected swift-integration.md, updated REQUIREMENTS.md
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@internal/server/server_test.go
@internal/server/handler_scan.go
@internal/server/handler_cleanup.go
@internal/server/protocol.go
@internal/server/server.go
@internal/engine/engine.go
@internal/engine/scanner.go
@internal/engine/engine_test.go
@internal/cleanup/cleanup.go
@docs/swift-integration.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add integration tests for streaming scan, cleanup, concurrent rejection, and skip params</name>
  <files>internal/server/server_test.go</files>
  <action>
Add 4 new integration tests to `internal/server/server_test.go`. All tests MUST use a mock engine (not `newTestEngine()` which uses real scanners and hits the filesystem). Create a `newMockTestEngine()` helper that registers 2 mock scanners using `engine.NewScanner()` with deterministic fake data.

**Important test infrastructure note:** The existing `readResponse` helper uses `json.NewDecoder` which internally buffers reads from the connection. For streaming tests that read multiple NDJSON lines from the same connection, this causes problems because the decoder may consume bytes beyond the first response. Instead, create a `readResponses` helper that uses `bufio.Scanner` to read lines and `json.Unmarshal` each line into a `Response`. This is the same approach the server uses for reading (see `NDJSONReader`). Keep the existing `readResponse` helper for backward compatibility with existing tests.

**Mock engine helper:**
```go
func newMockTestEngine() *engine.Engine {
    eng := engine.New()
    eng.Register(engine.NewScanner(engine.ScannerInfo{
        ID:   "mock-sys",
        Name: "Mock System",
    }, func() ([]scan.CategoryResult, error) {
        return []scan.CategoryResult{{
            Category:    "mock-caches",
            Description: "Mock Caches",
            TotalSize:   1024,
            Entries: []scan.ScanEntry{
                {Path: "/tmp/mock-test/cache1", Description: "Cache 1", Size: 512},
                {Path: "/tmp/mock-test/cache2", Description: "Cache 2", Size: 512},
            },
        }}, nil
    }))
    eng.Register(engine.NewScanner(engine.ScannerInfo{
        ID:   "mock-browser",
        Name: "Mock Browser",
    }, func() ([]scan.CategoryResult, error) {
        return []scan.CategoryResult{{
            Category:    "mock-browser-data",
            Description: "Mock Browser Data",
            TotalSize:   2048,
            Entries: []scan.ScanEntry{
                {Path: "/tmp/mock-test/browser1", Description: "Browser 1", Size: 2048},
            },
        }}, nil
    }))
    return eng
}
```

**Streaming response reader helper:**
```go
func readAllResponses(t *testing.T, conn net.Conn, timeout time.Duration) []Response {
    t.Helper()
    conn.SetReadDeadline(time.Now().Add(timeout))
    var responses []Response
    scanner := bufio.NewScanner(conn)
    for scanner.Scan() {
        var resp Response
        if err := json.Unmarshal(scanner.Bytes(), &resp); err != nil {
            t.Fatalf("unmarshal response: %v", err)
        }
        responses = append(responses, resp)
        // Check if this is a final response (result or error type).
        if resp.Type == ResponseResult || resp.Type == ResponseError {
            break
        }
    }
    if err := scanner.Err(); err != nil {
        // Ignore deadline exceeded -- we got what we needed.
        if !isTimeout(err) {
            t.Fatalf("scanner error: %v", err)
        }
    }
    return responses
}
```
Add a small `isTimeout` helper that checks for `net.Error` with `Timeout()`. This is needed because `SetReadDeadline` may fire between responses.

**Test 1: TestServer_ScanStreaming**
- Create server with `newMockTestEngine()`, use `os.TempDir()` for socket path (macOS 104-char limit)
- Connect, send `{"id":"s1","method":"scan"}` request
- Read all responses using `readAllResponses` with 5-second timeout
- Assert: at least 4 progress responses (scanner_start + scanner_done for each of the 2 mock scanners)
- Assert: progress responses have `type: "progress"` and result contains `event`, `scanner_id`, `label` fields
- Assert: exactly 1 final response with `type: "result"`
- Unmarshal final result, verify it has `categories` (non-empty), `total_size` (3072 = 1024+2048), and `token` (non-empty)

**Test 2: TestServer_ScanThenCleanup**
- Create server with `newMockTestEngine()`, use `os.TempDir()` for socket path
- Connect, send scan, collect all responses, extract token from final result
- Send cleanup request with the extracted token: `{"id":"c1","method":"cleanup","params":{"token":"<token>"}}`
- Read all cleanup responses using `readAllResponses`
- Assert: at least 1 progress response (cleanup events for the mock entries)
- Assert: final result is of type "result" with `removed`, `failed`, `bytes_freed` fields
- Note: Mock paths `/tmp/mock-test/*` do not exist on disk, so cleanup will report them as failed (that's fine -- we're testing the handler plumbing, not actual deletion)

**Test 3: TestServer_ConcurrentScanRejected**
- Create a mock engine with one SLOW scanner that blocks on a channel (similar to `TestScanAll_ContextCancellation` in engine_test.go)
- Use `os.TempDir()` for socket path
- Connect, send first scan request
- Wait briefly for the scan to start (read the first progress event with `scanner_start`)
- Send second scan request on the SAME connection
- The second request's response should be `type: "error"` with error containing "another operation is in progress"
- Release the blocking channel so the first scan completes
- Drain remaining responses
- Clean up: shutdown server

**Test 4: TestServer_ScanWithSkipParam**
- Create server with `newMockTestEngine()` (2 scanners: mock-sys producing "mock-caches", mock-browser producing "mock-browser-data")
- Connect, send scan with skip param: `{"id":"sk1","method":"scan","params":{"skip":["mock-caches"]}}`
- Read all responses
- In the final result, unmarshal categories and verify only "mock-browser-data" is present (not "mock-caches")
- total_size should be 2048 (only the browser data)

**For all tests:** Use `defer os.Remove(socketPath)` and `os.Remove(socketPath)` before creating the server (pattern from existing tests). Use `defer srv.Shutdown()` to clean up.
  </action>
  <verify>
Run `go test ./internal/server/... -v -run "TestServer_Scan|TestServer_Concurrent"` -- all 4 new tests pass.
Run `go test ./internal/server/... -count=1` -- all tests (existing + new) pass.
Run `go vet ./internal/server/...` -- no issues.
  </verify>
  <done>
4 new integration tests pass: TestServer_ScanStreaming verifies progress events and final result with token, TestServer_ScanThenCleanup verifies full scan-then-cleanup flow through socket, TestServer_ConcurrentScanRejected verifies busy flag rejection, TestServer_ScanWithSkipParam verifies skip filtering through socket. All existing tests continue to pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix Swift doc cleanup event names and update REQUIREMENTS.md</name>
  <files>docs/swift-integration.md, .planning/REQUIREMENTS.md</files>
  <action>
**Fix docs/swift-integration.md naming discrepancy:**

The Go implementation sends cleanup progress events with `event` values `cleanup_category_start` and `cleanup_entry` (from `engine.EventCleanupCategoryStart` and `engine.EventCleanupEntry` constants, passed through `handler_cleanup.go:62`). The Swift docs currently show `category_start` and `entry_progress` which do not match the wire format.

The Go implementation is canonical (it has tests and is already deployed). Update the Swift docs to match:

1. In the `cleanup` method example JSON, change:
   - `"event":"category_start"` to `"event":"cleanup_category_start"`
   - `"event":"entry_progress"` to `"event":"cleanup_entry"`

2. In the Swift `CleanupProgress` Codable struct comment, change:
   - `// "category_start", "entry_progress"` to `// "cleanup_category_start", "cleanup_entry"`

**Update REQUIREMENTS.md:**

Mark all Phase 10 requirements as complete:
- PROTO-02: pending -> complete
- PROTO-03: pending -> complete
- PROTO-04: pending -> complete
- PROTO-05: pending -> complete
- SRV-03: pending -> complete

This brings the total to 13/16 requirements complete (remaining 3 are Phase 11 HARD-* requirements).
  </action>
  <verify>
Verify the Swift doc example shows `cleanup_category_start` and `cleanup_entry` (not the old names).
Verify REQUIREMENTS.md shows all Phase 10 requirements as "complete".
Run `go test ./...` to confirm nothing was broken (docs are not compiled but this is a sanity check).
  </verify>
  <done>
Swift integration docs match the actual wire format for cleanup progress events. REQUIREMENTS.md reflects Phase 10 completion: PROTO-02, PROTO-03, PROTO-04, PROTO-05, SRV-03 all marked "complete". 13 of 16 total requirements complete.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/server/... -v -count=1` passes with all tests (existing 20 + 4 new = 24 tests)
- `go test ./... -count=1` passes across all packages
- `go vet ./...` reports no issues
- `gosec ./...` reports 0 issues
- `docs/swift-integration.md` cleanup event names match Go constants (`cleanup_category_start`, `cleanup_entry`)
- `.planning/REQUIREMENTS.md` shows PROTO-02 through PROTO-05 and SRV-03 as "complete"
</verification>

<success_criteria>
- 4 new integration tests exercise the 4 previously untested streaming handler flows through the Unix socket
- All tests use mock engines for deterministic, fast, filesystem-independent execution
- Scan streaming test verifies progress events (scanner_start, scanner_done) and final result (categories, total_size, token)
- Scan-then-cleanup test verifies full token round-trip and cleanup progress through socket
- Concurrent rejection test verifies busy flag error for overlapping scan requests
- Skip parameter test verifies category filtering through the socket protocol
- Swift docs accurately reflect the wire format
- All Phase 10 requirements marked complete
</success_criteria>

<output>
After completion, create `.planning/phases/10-scan-cleanup-handlers/10-01-SUMMARY.md`
</output>
