---
phase: 11-hardening-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/server/server.go
  - internal/server/server_test.go
  - docs/swift-integration.md
  - .planning/REQUIREMENTS.md
autonomous: true

must_haves:
  truths:
    - "Client disconnect during active scan does not crash the server or leak goroutines"
    - "Client disconnect during active cleanup does not crash the server or leak goroutines"
    - "Idle connections are closed after a configurable timeout"
    - "No dead code remains in the server package"
    - "All HARD requirements are marked complete in REQUIREMENTS.md"
    - "Swift integration docs describe timeout and disconnect behavior"
  artifacts:
    - path: "internal/server/server.go"
      provides: "Configurable IdleTimeout field on Server struct, no ReadTimeout constant"
      contains: "IdleTimeout"
    - path: "internal/server/server_test.go"
      provides: "Disconnect-during-scan, disconnect-during-cleanup, and idle timeout tests"
      contains: "TestServer_DisconnectDuringScan"
    - path: "docs/swift-integration.md"
      provides: "Timeout and disconnect behavior documentation for Swift clients"
      contains: "idle timeout"
    - path: ".planning/REQUIREMENTS.md"
      provides: "All HARD requirements marked complete"
      contains: "HARD-01.*complete"
  key_links:
    - from: "internal/server/server_test.go"
      to: "internal/server/server.go"
      via: "Server.IdleTimeout field override in tests"
      pattern: "srv\\.IdleTimeout\\s*="
    - from: "internal/server/server.go"
      to: "internal/server/server.go"
      via: "handleConnection uses s.IdleTimeout instead of constant"
      pattern: "s\\.IdleTimeout"
---

<objective>
Harden the server for production use by adding integration tests that verify graceful handling of client disconnects during active operations and idle connection timeouts. Clean up dead code, update requirements, and enhance Swift documentation.

Purpose: Prove that HARD-01, HARD-02, and HARD-03 requirements are satisfied with test evidence. The implementation is mostly done -- this plan closes the gap with tests, removes dead code, and documents behavior.

Output: Hardened server with 3 new integration tests, clean code (no dead constants), complete REQUIREMENTS.md, and enhanced Swift docs.
</objective>

<execution_context>
@/Users/gregor/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gregor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-hardening-documentation/11-RESEARCH.md
@internal/server/server.go
@internal/server/server_test.go
@internal/server/handler_scan.go
@internal/server/handler_cleanup.go
@internal/engine/engine.go
@docs/swift-integration.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make IdleTimeout configurable, remove dead ReadTimeout, add hardening tests</name>
  <files>internal/server/server.go, internal/server/server_test.go</files>
  <action>
**server.go changes:**

1. Remove the `ReadTimeout` constant (line 22-23, the `ReadTimeout = 30 * time.Second` -- it is dead code, never referenced anywhere).

2. Convert `IdleTimeout` from a package-level constant to a `DefaultIdleTimeout` constant, and add an `IdleTimeout time.Duration` field to the `Server` struct:
   - Rename `IdleTimeout` constant to `DefaultIdleTimeout` (keep same value: `5 * time.Minute`)
   - Add `IdleTimeout time.Duration` field to the Server struct
   - In `New()`, initialize `s.IdleTimeout = DefaultIdleTimeout`
   - In `handleConnection()`, change `conn.SetReadDeadline(time.Now().Add(IdleTimeout))` to `conn.SetReadDeadline(time.Now().Add(s.IdleTimeout))`

That is the only code change. The constants section becomes a single `DefaultIdleTimeout` constant. The rest is test additions.

**server_test.go additions (3 new tests):**

3. `TestServer_DisconnectDuringScan` -- Verifies HARD-01 for scan operations:
   - Create an engine with a single blocking scanner (channel-based: blocks on `<-blocker` in the scan function)
   - Start the server on a socket in `os.TempDir()` (use pattern `mc-test-disc-scan.sock`)
   - Connect, send a scan request, read the first progress event (scanner_start) to confirm the scan is underway
   - Close the connection (simulating client disconnect)
   - Release the blocker channel so the scanner goroutine can complete
   - Wait briefly (200ms) for the server to process the disconnect
   - Connect again and send a ping to verify the server is still operational and accepting connections
   - Assert ping returns a result response

4. `TestServer_DisconnectDuringCleanup` -- Verifies HARD-01 for cleanup operations:
   - Create an engine with a mock scanner that returns entries with paths under `os.TempDir()` that actually exist (create temp files via `os.CreateTemp`)
   - Start the server, connect, send a scan request, read all responses to get the token
   - Send a cleanup request with the valid token
   - Read the first progress event (cleanup_category_start or cleanup_entry) to confirm cleanup has started
   - Close the connection (client disconnect)
   - Wait briefly (200ms) for cleanup to finish (cleanup.Execute continues to completion by design -- this is correct behavior since file deletion should not be interrupted)
   - Connect again and send a ping to verify server recovery
   - Assert ping returns a result response
   - NOTE: The cleanup will succeed on the temp files, which is fine -- we are testing server resilience, not cleanup logic

5. `TestServer_IdleTimeoutClosesConnection` -- Verifies HARD-02:
   - Create server with mock engine, set `srv.IdleTimeout = 100 * time.Millisecond` after `New()`
   - Start server, connect, send a ping, read the ping response (confirms connection is alive)
   - Sleep for 200ms (beyond the 100ms idle timeout)
   - Attempt to send another ping -- the write may succeed (kernel buffer), so also attempt to read
   - The read should fail (connection closed by server due to idle timeout)
   - Use `conn.SetReadDeadline` with a short deadline (500ms) to avoid hanging if the timeout didn't fire
   - Assert that the read returns an error (EOF or timeout, either confirms connection was closed)

Follow established test patterns:
- Use `os.TempDir()` for socket paths (macOS 104-char limit)
- Use `waitForSocket(t, socketPath)` helper
- Use `sendRequest(t, conn, req)` and `readResponse(t, conn)` helpers
- Use `readAllResponses(t, conn, timeout)` for streaming responses
- Defer `os.Remove(socketPath)` and `srv.Shutdown()` and `cancel()`
  </action>
  <verify>
Run `go test ./internal/server/... -v -run "TestServer_Disconnect|TestServer_IdleTimeout"` -- all 3 new tests pass.
Run `go test ./internal/server/...` -- all existing tests still pass (no regressions).
Run `go vet ./internal/server/...` -- no issues.
Verify ReadTimeout is gone: `grep -r "ReadTimeout" internal/server/` returns nothing.
  </verify>
  <done>
Three new integration tests pass: DisconnectDuringScan, DisconnectDuringCleanup, IdleTimeoutClosesConnection. IdleTimeout is a configurable Server struct field (default 5 minutes). ReadTimeout dead code removed. All existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Swift docs with timeout/disconnect guidance and mark requirements complete</name>
  <files>docs/swift-integration.md, .planning/REQUIREMENTS.md</files>
  <action>
**docs/swift-integration.md enhancements:**

1. In the "Error Handling" section at the bottom, expand the existing bullet points for "Client disconnect" and "Idle timeout" with more detail. Add a new subsection `### Connection Behavior` between the "Error Handling" heading and the "Testing with socat" heading. Content:

   - **Idle timeout:** The server closes connections idle for more than 5 minutes (no messages sent or received). Swift clients should handle `NWConnection.State.failed` or `.waiting` by reconnecting. If your app has long idle periods, send periodic `ping` requests as a keepalive mechanism.
   - **Client disconnect during scan:** If the client disconnects while a scan is running, the server cancels the scan and cleans up. No goroutine leaks occur. The server immediately accepts new connections.
   - **Client disconnect during cleanup:** If the client disconnects while cleanup is running, file deletion continues to completion (by design -- partially-deleted state is worse than completing the operation). Progress events are dropped. The server accepts new connections after cleanup finishes.
   - **Reconnection:** After any disconnect (intentional, timeout, or crash), the client can simply open a new connection to the same socket path. A new `scan` must be performed before `cleanup` (tokens are invalidated on disconnect).

2. In the Swift `startReceiving()` method comment, add a note about NDJSON buffering: "Note: This simple approach splits on newlines but does not handle partial messages that may arrive across multiple `receive` calls. For production use, accumulate received data in a buffer and only process complete lines (terminated by `\\n`)."

**REQUIREMENTS.md update:**

3. Update all three HARD requirements to `complete`:
   - `HARD-01`: Change `pending` to `complete` (tested by DisconnectDuringScan, DisconnectDuringCleanup, and existing ClientDisconnectHandledGracefully)
   - `HARD-02`: Change `pending` to `complete` (tested by IdleTimeoutClosesConnection; keepalive handled by idle timeout on Unix sockets)
   - `HARD-03`: Change `pending` to `complete` (already fully implemented and tested in Phases 8 and 10)

No other file changes.
  </action>
  <verify>
Verify REQUIREMENTS.md has no remaining `pending` entries: `grep "pending" .planning/REQUIREMENTS.md` returns nothing.
Verify Swift docs contain new section: `grep "Connection Behavior" docs/swift-integration.md` returns a match.
Verify docs mention idle timeout detail: `grep "5 minutes" docs/swift-integration.md` returns at least one match.
  </verify>
  <done>
Swift integration docs have a "Connection Behavior" section documenting idle timeout, disconnect-during-scan, disconnect-during-cleanup, and reconnection guidance. NDJSON buffering caveat noted. All three HARD requirements (HARD-01, HARD-02, HARD-03) marked complete in REQUIREMENTS.md.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` -- all tests pass across entire project (no regressions)
2. `go vet ./...` -- no issues
3. `gosec ./...` -- no new findings (existing nosec annotations preserved)
4. `grep "ReadTimeout" internal/server/` -- returns nothing (dead code removed)
5. `grep "pending" .planning/REQUIREMENTS.md` -- returns nothing (all requirements complete)
6. `grep "Connection Behavior" docs/swift-integration.md` -- section exists
</verification>

<success_criteria>
- All existing tests pass (no regressions)
- 3 new server integration tests pass: DisconnectDuringScan, DisconnectDuringCleanup, IdleTimeoutClosesConnection
- IdleTimeout is a configurable field on Server struct (default 5 minutes)
- ReadTimeout dead constant is removed
- HARD-01, HARD-02, HARD-03 all marked complete in REQUIREMENTS.md
- Swift docs include Connection Behavior section with timeout/disconnect/reconnection guidance
- `go vet` and `gosec` report no issues
</success_criteria>

<output>
After completion, create `.planning/phases/11-hardening-documentation/11-01-SUMMARY.md`
</output>
