# Архитектура безопасности

Этот документ описывает архитектуру безопасности mac-cleaner -- CLI-инструмента, который сканирует и удаляет файлы в macOS. Учитывая деструктивный характер удаления файлов, инструмент реализует несколько уровней защиты для предотвращения случайной потери данных или повреждения системы.

## Модель угроз

**Что делает инструмент:** Сканирует известные расположения кэшей, логов и временных файлов в macOS и при необходимости удаляет их для освобождения дискового пространства.

**Что может пойти не так:**
- Удаление системных файлов, приводящее к невозможности загрузки macOS
- Удаление пользовательских данных за пределами предусмотренных каталогов кэша
- Атаки через символические ссылки, перенаправляющие удаление на непредусмотренные цели
- Обход границ каталогов через манипуляции с путями (path traversal)

**Допущения об атакующем:** Инструмент работает от имени текущего пользователя без повышенных привилегий. Основной риск -- ошибки в построении или валидации путей, а не внешние злоумышленники. Тем не менее атаки на основе символических ссылок от других процессов в той же системе учитываются.

## Архитектура безопасности

mac-cleaner использует многоуровневую стратегию защиты. Каждый уровень независим -- сбой на одном уровне перехватывается следующим.

### Уровень 1: Жестко заданное построение путей

Все цели сканирования жестко заданы в реализациях сканеров (`pkg/*/scanner.go`). Пути строятся с помощью `filepath.Join()` от домашнего каталога пользователя -- никогда из пользовательского ввода, аргументов CLI или переменных окружения (за исключением `$TMPDIR` для QuickLook, который проходит валидацию).

### Уровень 2: Валидация путей (`internal/safety/`)

Каждый путь проверяется функцией `safety.IsPathBlocked()` перед любой операцией. Эта функция:

1. **Нормализует** путь с помощью `filepath.Clean()` для удаления компонентов `..`
2. **Разрешает символические ссылки** с помощью `filepath.EvalSymlinks()` для получения реального пути в файловой системе
3. **Проверяет критические пути** -- точные совпадения с `/`, `/Users`, `/Library`, `/Applications`, `/private`, `/var`, `/etc`, `/Volumes`, `/opt`, `/cores` всегда блокируются
4. **Проверяет пути swap/VM** -- `/private/var/vm` и дочерние пути всегда блокируются для предотвращения паники ядра
5. **Проверяет SIP-защищенные пути** -- `/System`, `/usr`, `/bin`, `/sbin` блокируются (с `/usr/local` в качестве исключения)
6. **Обеспечивает ограничение домашним каталогом** -- все удаляемые пути должны находиться в домашнем каталоге пользователя (`~/`) или в `/private/var/folders/` (для кэшей QuickLook). Все остальное блокируется

### Уровень 3: Повторная валидация при удалении

`cleanup.Execute()` повторно проверяет `safety.IsPathBlocked()` непосредственно перед вызовом `os.RemoveAll()` для каждого пути. Это перехватывает любые проблемы, которые могут возникнуть между моментом сканирования и моментом удаления.

### Уровень 4: Подтверждение пользователя

Перед любым удалением пользователь должен явно подтвердить операцию. Это можно сделать через:
- **Интерактивный режим** (по умолчанию) -- проводит по каждой категории для одобрения
- **Запрос подтверждения** -- явное да/нет перед массовым удалением
- **Режим предварительного просмотра** (`--dry-run`) -- показывает, что будет удалено, без фактического удаления
- **Принудительный режим** (`--force`) -- пропускает подтверждение (явное согласие)

### Уровень 5: Классификация рисков

Каждой категории сканирования присваивается уровень риска (`safe`, `moderate` или `risky`), отображаемый пользователю перед подтверждением. Это помогает пользователям принимать обоснованные решения о том, что удалять.

## Подробности валидации путей

### Обработка символических ссылок

- **При сканировании** используются `os.Lstat()` и `filepath.WalkDir()`, которые НЕ следуют по символическим ссылкам. Файлы, на которые указывают символические ссылки, не учитываются при расчете размера.
- **Проверки безопасности** используют `filepath.EvalSymlinks()` для разрешения реального пути перед проверкой по спискам блокировки. Символическая ссылка из `~/Library/Caches/safe-dir` на `/System/Library` будет обнаружена и заблокирована.
- Если разрешение символической ссылки не удается для существующего пути (не `IsNotExist`), путь блокируется в целях безопасности.

### Безопасность границ путей

`pathHasPrefix()` проверяет, что путь равен префиксу или является его собственным дочерним элементом (разделенным `/`). Это предотвращает ложные срабатывания, такие как совпадение `/SystemVolume` с `/System`.

### Валидация TMPDIR

Сканер QuickLook получает каталог кэша из `$TMPDIR`. Перед использованием этого пути:
1. Проверяется, что `$TMPDIR` содержит `/var/folders/` (конвенция macOS)
2. Производный каталог кэша проверяется через `safety.IsPathBlocked()`
3. Отдельные записи внутри каталога кэша также проходят проверку безопасности

## Внешние команды

Инструмент выполняет две внешние команды:
- `docker system df` -- для запроса использования диска Docker
- `/usr/libexec/PlistBuddy` -- для чтения идентификаторов бандлов из файлов `.plist`

Обе используют `exec.CommandContext()` с аргументами, передаваемыми как отдельные параметры (не через оболочку). Риск инъекции команд оболочки отсутствует. Бинарные файлы команд проверяются с помощью `exec.LookPath()` перед выполнением.

## Чего мы не делаем

- **Нет сетевого доступа** -- инструмент никогда не выполняет сетевые запросы
- **Нет повышения привилегий** -- никакого `sudo`, никакого setuid, никаких entitlements
- **Нет записи файлов** -- инструмент только читает (сканирование) и удаляет (очистка)
- **Нет модификации системы** -- никаких изменений настроек, никакого управления демонами
- **Нет пользовательского ввода в путях** -- все пути формируются из жестко заданных баз и перечисления файловой системы

## Инструменты безопасности CI

Проект использует следующие инструменты безопасности в CI:
- **gosec** -- статический анализ безопасности для Go (обнаруживает обход путей, непроверенные ошибки, проблемы с правами доступа к файлам)
- **govulncheck** -- сканирование уязвимостей зависимостей с анализом достижимости
- **Race detector** -- `go test -race` обнаруживает гонки данных в параллельных путях кода
- **Фаззинг-тестирование** -- `FuzzIsPathBlocked` обнаруживает граничные случаи в валидации путей

## Сообщение об уязвимостях

Если вы обнаружили уязвимость безопасности, пожалуйста, сообщите о ней ответственно:

1. **НЕ создавайте публичный issue**
2. Отправьте электронное письмо мейнтейнеру или воспользуйтесь функцией приватного сообщения об уязвимостях на GitHub
3. Включите описание уязвимости, шаги для воспроизведения и потенциальное воздействие
4. Предоставьте разумное время для исправления перед публичным раскрытием
