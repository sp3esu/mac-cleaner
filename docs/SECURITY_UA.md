# Архітектура безпеки

Цей документ описує архітектуру безпеки mac-cleaner -- CLI-інструменту, який сканує та видаляє файли в macOS. Зважаючи на деструктивний характер видалення файлів, інструмент реалізує декілька рівнів захисту для запобігання випадковій втраті даних або пошкодженню системи.

## Модель загроз

**Що робить інструмент:** Сканує відомі розташування кешів, логів та тимчасових файлів у macOS і за потреби видаляє їх для звільнення дискового простору.

**Що може піти не так:**
- Видалення системних файлів, що призводить до неможливості завантаження macOS
- Видалення даних користувача за межами передбачених каталогів кешу
- Атаки через символічні посилання, що перенаправляють видалення на непередбачені цілі
- Обхід меж каталогів через маніпуляції зі шляхами (path traversal)

**Припущення щодо зловмисника:** Інструмент працює від імені поточного користувача без підвищених привілеїв. Основний ризик -- помилки в побудові або валідації шляхів, а не зовнішні зловмисники. Проте атаки на основі символічних посилань від інших процесів у тій самій системі враховуються.

## Архітектура безпеки

mac-cleaner використовує багаторівневу стратегію захисту. Кожен рівень є незалежним -- збій на одному рівні перехоплюється наступним.

### Рівень 1: Жорстко задана побудова шляхів

Усі цілі сканування жорстко задані в реалізаціях сканерів (`pkg/*/scanner.go`). Шляхи будуються за допомогою `filepath.Join()` від домашнього каталогу користувача -- ніколи з введення користувача, аргументів CLI або змінних середовища (за винятком `$TMPDIR` для QuickLook, який проходить валідацію).

### Рівень 2: Валідація шляхів (`internal/safety/`)

Кожен шлях перевіряється функцією `safety.IsPathBlocked()` перед будь-якою операцією. Ця функція:

1. **Нормалізує** шлях за допомогою `filepath.Clean()` для видалення компонентів `..`
2. **Розв'язує символічні посилання** за допомогою `filepath.EvalSymlinks()` для отримання реального шляху у файловій системі
3. **Перевіряє критичні шляхи** -- точні збіги з `/`, `/Users`, `/Library`, `/Applications`, `/private`, `/var`, `/etc`, `/Volumes`, `/opt`, `/cores` завжди блокуються
4. **Перевіряє шляхи swap/VM** -- `/private/var/vm` та дочірні шляхи завжди блокуються для запобігання паніки ядра
5. **Перевіряє SIP-захищені шляхи** -- `/System`, `/usr`, `/bin`, `/sbin` блокуються (з `/usr/local` як винятком)
6. **Забезпечує обмеження домашнім каталогом** -- усі шляхи, що підлягають видаленню, повинні знаходитися в домашньому каталозі користувача (`~/`) або в `/private/var/folders/` (для кешів QuickLook). Все інше блокується

### Рівень 3: Повторна валідація під час видалення

`cleanup.Execute()` повторно перевіряє `safety.IsPathBlocked()` безпосередньо перед викликом `os.RemoveAll()` для кожного шляху. Це перехоплює будь-які проблеми, що можуть виникнути між моментом сканування та моментом видалення.

### Рівень 4: Підтвердження користувача

Перед будь-яким видаленням користувач повинен явно підтвердити операцію. Це можна зробити через:
- **Інтерактивний режим** (за замовчуванням) -- проводить через кожну категорію для схвалення
- **Запит підтвердження** -- явне так/ні перед масовим видаленням
- **Режим попереднього перегляду** (`--dry-run`) -- показує, що буде видалено, без фактичного видалення
- **Примусовий режим** (`--force`) -- пропускає підтвердження (явна згода)

### Рівень 5: Класифікація ризиків

Кожній категорії сканування присвоюється рівень ризику (`safe`, `moderate` або `risky`), що відображається користувачу перед підтвердженням. Це допомагає користувачам приймати обгрунтовані рішення щодо того, що видаляти.

## Деталі валідації шляхів

### Обробка символічних посилань

- **При скануванні** використовуються `os.Lstat()` та `filepath.WalkDir()`, які НЕ переходять за символічними посиланнями. Файли, на які вказують символічні посилання, не враховуються при розрахунку розміру.
- **Перевірки безпеки** використовують `filepath.EvalSymlinks()` для розв'язання реального шляху перед перевіркою за списками блокування. Символічне посилання з `~/Library/Caches/safe-dir` на `/System/Library` буде виявлене та заблоковане.
- Якщо розв'язання символічного посилання не вдається для існуючого шляху (не `IsNotExist`), шлях блокується з міркувань безпеки.

### Безпека меж шляхів

`pathHasPrefix()` перевіряє, чи шлях дорівнює префіксу або є його власним дочірнім елементом (розділеним `/`). Це запобігає хибним спрацюванням, таким як збіг `/SystemVolume` з `/System`.

### Валідація TMPDIR

Сканер QuickLook отримує каталог кешу з `$TMPDIR`. Перед використанням цього шляху:
1. Перевіряється, що `$TMPDIR` містить `/var/folders/` (конвенція macOS)
2. Похідний каталог кешу перевіряється через `safety.IsPathBlocked()`
3. Окремі записи всередині каталогу кешу також проходять перевірку безпеки

## Зовнішні команди

Інструмент виконує дві зовнішні команди:
- `docker system df` -- для запиту використання диска Docker
- `/usr/libexec/PlistBuddy` -- для читання ідентифікаторів бандлів з файлів `.plist`

Обидві використовують `exec.CommandContext()` з аргументами, що передаються як окремі параметри (не через оболонку). Ризик ін'єкції команд оболонки відсутній. Бінарні файли команд перевіряються за допомогою `exec.LookPath()` перед виконанням.

## Чого ми не робимо

- **Немає мережевого доступу** -- інструмент ніколи не виконує мережеві запити
- **Немає підвищення привілеїв** -- жодного `sudo`, жодного setuid, жодних entitlements
- **Немає запису файлів** -- інструмент лише читає (сканування) та видаляє (очищення)
- **Немає модифікації системи** -- жодних змін налаштувань, жодного керування демонами
- **Немає введення користувача у шляхах** -- усі шляхи формуються з жорстко заданих баз та перелічення файлової системи

## Інструменти безпеки CI

Проєкт використовує наступні інструменти безпеки в CI:
- **gosec** -- статичний аналіз безпеки для Go (виявляє обхід шляхів, неперевірені помилки, проблеми з правами доступу до файлів)
- **govulncheck** -- сканування вразливостей залежностей з аналізом досяжності
- **Race detector** -- `go test -race` виявляє перегони даних у паралельних шляхах коду
- **Фазинг-тестування** -- `FuzzIsPathBlocked` виявляє граничні випадки у валідації шляхів

## Повідомлення про вразливості

Якщо ви виявили вразливість безпеки, будь ласка, повідомте про неї відповідально:

1. **НЕ створюйте публічний issue**
2. Надішліть електронний лист мейнтейнеру або скористайтеся функцією приватного повідомлення про вразливості на GitHub
3. Додайте опис вразливості, кроки для відтворення та потенційний вплив
4. Надайте розумний час для виправлення перед публічним розкриттям
